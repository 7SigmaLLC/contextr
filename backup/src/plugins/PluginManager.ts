// Plugin system architecture for contextr
// This file defines the core plugin interfaces and management system

import * as path from 'path';
import * as fs from 'fs-extra';
import { CollectedFile, FileCollectorConfig } from '../types';

/**
 * Plugin types supported by the system
 */
export enum PluginType {
  SECURITY_SCANNER = 'security-scanner',
  OUTPUT_RENDERER = 'output-renderer',
  LLM_REVIEWER = 'llm-reviewer'
}

/**
 * Base interface for all plugins
 */
export interface Plugin {
  /** Unique identifier for the plugin */
  id: string;
  
  /** Human-readable name of the plugin */
  name: string;
  
  /** Plugin type */
  type: PluginType;
  
  /** Plugin version */
  version: string;
  
  /** Plugin description */
  description: string;
  
  /** Initialize the plugin */
  initialize?(): Promise<void>;
  
  /** Clean up resources when plugin is disabled */
  cleanup?(): Promise<void>;
}

/**
 * Security scanner plugin interface
 */
export interface SecurityScannerPlugin extends Plugin {
  type: PluginType.SECURITY_SCANNER;
  
  /**
   * Scan files for security issues
   * @param files Files to scan
   * @param config Configuration for the scanner
   * @returns Files with security warnings added to metadata
   */
  scanFiles(files: CollectedFile[], config?: any): Promise<CollectedFile[]>;
  
  /**
   * Get security warnings as a separate report
   * @param files Files to scan
   * @param config Configuration for the scanner
   * @returns Security report
   */
  generateSecurityReport?(files: CollectedFile[], config?: any): Promise<SecurityReport>;
}

/**
 * Output renderer plugin interface
 */
export interface OutputRendererPlugin extends Plugin {
  type: PluginType.OUTPUT_RENDERER;
  
  /**
   * Render files to a specific output format
   * @param files Files to render
   * @param config Configuration for the renderer
   * @returns Rendered output
   */
  render(files: CollectedFile[], config?: any): Promise<string>;
  
  /**
   * Get the format name for this renderer
   */
  getFormatName(): string;
}

/**
 * LLM reviewer plugin interface
 */
export interface LLMReviewerPlugin extends Plugin {
  type: PluginType.LLM_REVIEWER;
  
  /**
   * Review files using an LLM
   * @param files Files to review
   * @param config Configuration for the reviewer
   * @returns Reviewed files with additional metadata
   */
  reviewFiles(files: CollectedFile[], config?: any): Promise<CollectedFile[]>;
  
  /**
   * Generate a summary of the files
   * @param files Files to summarize
   * @param config Configuration for the summarizer
   * @returns Summary text
   */
  generateSummary?(files: CollectedFile[], config?: any): Promise<string>;
  
  /**
   * Check if the LLM is available (e.g., model is downloaded)
   */
  isAvailable(): Promise<boolean>;
}

/**
 * Security issue severity levels
 */
export enum SecurityIssueSeverity {
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error',
  CRITICAL = 'critical'
}

/**
 * Security issue found in a file
 */
export interface SecurityIssue {
  /** File path where the issue was found */
  filePath: string;
  
  /** Line number where the issue was found (1-based) */
  lineNumber?: number;
  
  /** Issue severity */
  severity: SecurityIssueSeverity;
  
  /** Issue description */
  description: string;
  
  /** Suggested remediation */
  remediation?: string;
  
  /** Raw content that triggered the issue (may be redacted for sensitive data) */
  content?: string;
}

/**
 * Security report generated by a scanner
 */
export interface SecurityReport {
  /** Scanner that generated the report */
  scannerId: string;
  
  /** Issues found */
  issues: SecurityIssue[];
  
  /** Summary of findings */
  summary: {
    totalFiles: number;
    filesWithIssues: number;
    issuesBySeverity: Record<SecurityIssueSeverity, number>;
  };
}

/**
 * Plugin manager for loading and managing plugins
 */
export class PluginManager {
  private plugins: Map<string, Plugin> = new Map();
  private securityScanners: Map<string, SecurityScannerPlugin> = new Map();
  private outputRenderers: Map<string, OutputRendererPlugin> = new Map();
  private llmReviewers: Map<string, LLMReviewerPlugin> = new Map();
  
  /**
   * Create a new plugin manager
   * @param pluginsDir Directory where plugins are located
   */
  constructor(private pluginsDir: string = '') {
    // Default to plugins directory in user's home directory
    if (!this.pluginsDir) {
      this.pluginsDir = path.join(process.env.HOME || process.env.USERPROFILE || '', '.contextr', 'plugins');
    }
  }
  
  /**
   * Load all plugins from the plugins directory
   */
  async loadPlugins(): Promise<void> {
    // Create plugins directory if it doesn't exist
    await fs.ensureDir(this.pluginsDir);
    
    // Get all subdirectories in the plugins directory
    const pluginDirs = await fs.readdir(this.pluginsDir);
    
    for (const dir of pluginDirs) {
      const pluginDir = path.join(this.pluginsDir, dir);
      const stat = await fs.stat(pluginDir);
      
      if (stat.isDirectory()) {
        try {
          await this.loadPlugin(pluginDir);
        } catch (error) {
          console.error(`Failed to load plugin from ${pluginDir}:`, error);
        }
      }
    }
    
    console.log(`Loaded ${this.plugins.size} plugins`);
  }
  
  /**
   * Load a plugin from a directory
   * @param pluginDir Directory containing the plugin
   */
  async loadPlugin(pluginDir: string): Promise<void> {
    const indexPath = path.join(pluginDir, 'index.js');
    
    if (!await fs.pathExists(indexPath)) {
      throw new Error(`Plugin index.js not found in ${pluginDir}`);
    }
    
    try {
      // Load the plugin
      const pluginModule = require(indexPath);
      const plugin = pluginModule.default || pluginModule;
      
      // Validate plugin
      if (!plugin.id || !plugin.name || !plugin.type || !plugin.version) {
        throw new Error(`Invalid plugin format: missing required fields`);
      }
      
      // Initialize plugin if needed
      if (plugin.initialize) {
        await plugin.initialize();
      }
      
      // Register plugin
      this.registerPlugin(plugin);
      
    } catch (error) {
      throw new Error(`Failed to load plugin: ${error.message}`);
    }
  }
  
  /**
   * Register a plugin with the manager
   * @param plugin Plugin to register
   */
  registerPlugin(plugin: Plugin): void {
    // Check if plugin with this ID is already registered
    if (this.plugins.has(plugin.id)) {
      throw new Error(`Plugin with ID ${plugin.id} is already registered`);
    }
    
    // Add to general plugins map
    this.plugins.set(plugin.id, plugin);
    
    // Add to type-specific map
    switch (plugin.type) {
      case PluginType.SECURITY_SCANNER:
        this.securityScanners.set(plugin.id, plugin as SecurityScannerPlugin);
        break;
      case PluginType.OUTPUT_RENDERER:
        this.outputRenderers.set(plugin.id, plugin as OutputRendererPlugin);
        break;
      case PluginType.LLM_REVIEWER:
        this.llmReviewers.set(plugin.id, plugin as LLMReviewerPlugin);
        break;
      default:
        console.warn(`Unknown plugin type: ${plugin.type}`);
    }
    
    console.log(`Registered plugin: ${plugin.name} (${plugin.id})`);
  }
  
  /**
   * Get all registered plugins
   */
  getAllPlugins(): Plugin[] {
    return Array.from(this.plugins.values());
  }
  
  /**
   * Get all security scanner plugins
   */
  getSecurityScanners(): SecurityScannerPlugin[] {
    return Array.from(this.securityScanners.values());
  }
  
  /**
   * Get all output renderer plugins
   */
  getOutputRenderers(): OutputRendererPlugin[] {
    return Array.from(this.outputRenderers.values());
  }
  
  /**
   * Get all LLM reviewer plugins
   */
  getLLMReviewers(): LLMReviewerPlugin[] {
    return Array.from(this.llmReviewers.values());
  }
  
  /**
   * Get a plugin by ID
   * @param id Plugin ID
   */
  getPlugin(id: string): Plugin | undefined {
    return this.plugins.get(id);
  }
  
  /**
   * Get a security scanner plugin by ID
   * @param id Plugin ID
   */
  getSecurityScanner(id: string): SecurityScannerPlugin | undefined {
    return this.securityScanners.get(id);
  }
  
  /**
   * Get an output renderer plugin by ID
   * @param id Plugin ID
   */
  getOutputRenderer(id: string): OutputRendererPlugin | undefined {
    return this.outputRenderers.get(id);
  }
  
  /**
   * Get an LLM reviewer plugin by ID
   * @param id Plugin ID
   */
  getLLMReviewer(id: string): LLMReviewerPlugin | undefined {
    return this.llmReviewers.get(id);
  }
  
  /**
   * Run security scanners on files
   * @param files Files to scan
   * @param scannerIds IDs of scanners to use (all if not specified)
   * @param config Configuration for scanners
   */
  async runSecurityScanners(
    files: CollectedFile[], 
    scannerIds?: string[], 
    config?: any
  ): Promise<CollectedFile[]> {
    let result = [...files];
    
    const scanners = scannerIds 
      ? scannerIds.map(id => this.getSecurityScanner(id)).filter(Boolean) as SecurityScannerPlugin[]
      : this.getSecurityScanners();
    
    for (const scanner of scanners) {
      result = await scanner.scanFiles(result, config);
    }
    
    return result;
  }
  
  /**
   * Generate security reports for files
   * @param files Files to scan
   * @param scannerIds IDs of scanners to use (all if not specified)
   * @param config Configuration for scanners
   */
  async generateSecurityReports(
    files: CollectedFile[], 
    scannerIds?: string[], 
    config?: any
  ): Promise<SecurityReport[]> {
    const reports: SecurityReport[] = [];
    
    const scanners = scannerIds 
      ? scannerIds.map(id => this.getSecurityScanner(id)).filter(Boolean) as SecurityScannerPlugin[]
      : this.getSecurityScanners();
    
    for (const scanner of scanners) {
      if (scanner.generateSecurityReport) {
        const report = await scanner.generateSecurityReport(files, config);
        reports.push(report);
      }
    }
    
    return reports;
  }
  
  /**
   * Render files using an output renderer
   * @param files Files to render
   * @param rendererId ID of renderer to use
   * @param config Configuration for renderer
   */
  async renderOutput(
    files: CollectedFile[], 
    rendererId: string, 
    config?: any
  ): Promise<string> {
    const renderer = this.getOutputRenderer(rendererId);
    
    if (!renderer) {
      throw new Error(`Output renderer with ID ${rendererId} not found`);
    }
    
    return await renderer.render(files, config);
  }
  
  /**
   * Review files using LLM reviewers
   * @param files Files to review
   * @param reviewerIds IDs of reviewers to use (all if not specified)
   * @param config Configuration for reviewers
   */
  async reviewFiles(
    files: CollectedFile[], 
    reviewerIds?: string[], 
    config?: any
  ): Promise<CollectedFile[]> {
    let result = [...files];
    
    const reviewers = reviewerIds 
      ? reviewerIds.map(id => this.getLLMReviewer(id)).filter(Boolean) as LLMReviewerPlugin[]
      : this.getLLMReviewers();
    
    for (const reviewer of reviewers) {
      // Check if reviewer is available
      const available = await reviewer.isAvailable();
      if (!available) {
        console.warn(`LLM reviewer ${reviewer.id} is not available, skipping`);
        continue;
      }
      
      result = await reviewer.reviewFiles(result, config);
    }
    
    return result;
  }
  
  /**
   * Generate summaries for files using LLM reviewers
   * @param files Files to summarize
   * @param reviewerIds IDs of reviewers to use (all if not specified)
   * @param config Configuration for reviewers
   */
  async generateSummaries(
    files: CollectedFile[], 
    reviewerIds?: string[], 
    config?: any
  ): Promise<Record<string, string>> {
    const summaries: Record<string, string> = {};
    
    const reviewers = reviewerIds 
      ? reviewerIds.map(id => this.getLLMReviewer(id)).filter(Boolean) as LLMReviewerPlugin[]
      : this.getLLMReviewers();
    
    for (const reviewer of reviewers) {
      // Check if reviewer is available and has generateSummary method
      const available = await reviewer.isAvailable();
      if (!available || !reviewer.generateSummary) {
        continue;
      }
      
      const summary = await reviewer.generateSummary(files, config);
      summaries[reviewer.id] = summary;
    }
    
    return summaries;
  }
  
  /**
   * Unload and clean up all plugins
   */
  async unloadPlugins(): Promise<void> {
    for (const [id, plugin] of this.plugins.entries()) {
      try {
        if (plugin.cleanup) {
          await plugin.cleanup();
        }
      } catch (error) {
        console.error(`Error cleaning up plugin ${id}:`, error);
      }
    }
    
    this.plugins.clear();
    this.securityScanners.clear();
    this.outputRenderers.clear();
    this.llmReviewers.clear();
  }
}

// Export a singleton instance
export const pluginManager = new PluginManager();
