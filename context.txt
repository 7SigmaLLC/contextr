[1m[34m=== Directory Tree ===[39m[22m
[1m.[22m
â””â”€â”€ [33msrc[39m
    â”œâ”€â”€ [33mFileContextBuilder.ts[39m
    â”œâ”€â”€ [33mindex.ts[39m
    â”œâ”€â”€ [33mcli[39m
    â”‚   â”œâ”€â”€ [33mindex.ts[39m
    â”‚   â””â”€â”€ [33mstudio[39m
    â”‚       â”œâ”€â”€ [33mindex.ts[39m
    â”‚       â””â”€â”€ [33mpublic[39m
    â”‚           â”œâ”€â”€ [33mindex.html[39m
    â”‚           â””â”€â”€ [33mmain.js[39m
    â”œâ”€â”€ [33mcollector[39m
    â”‚   â”œâ”€â”€ [33mFileCollector.ts[39m
    â”‚   â”œâ”€â”€ [33mFileContentSearch.ts[39m
    â”‚   â”œâ”€â”€ [33mListOnlySupport.ts[39m
    â”‚   â”œâ”€â”€ [33mRegexPatternMatcher.ts[39m
    â”‚   â””â”€â”€ [33mWhitelistBlacklist.ts[39m
    â”œâ”€â”€ [33mplugins[39m
    â”‚   â”œâ”€â”€ [33mPluginCLI.ts[39m
    â”‚   â”œâ”€â”€ [33mPluginEnabledFileContextBuilder.ts[39m
    â”‚   â”œâ”€â”€ [33mPluginManager.ts[39m
    â”‚   â”œâ”€â”€ [33moutput-renderers[39m
    â”‚   â”‚   â”œâ”€â”€ [33mHTMLRenderer.ts[39m
    â”‚   â”‚   â””â”€â”€ [33mMarkdownRenderer.ts[39m
    â”‚   â”œâ”€â”€ [33mllm-reviewers[39m
    â”‚   â”‚   â”œâ”€â”€ [33mBaseLLMReviewer.ts[39m
    â”‚   â”‚   â””â”€â”€ [33mLocalLLMReviewer.ts[39m
    â”‚   â””â”€â”€ [33msecurity-scanners[39m
    â”‚       â”œâ”€â”€ [33mGitIgnoreSecurityScanner.ts[39m
    â”‚       â””â”€â”€ [33mSensitiveDataSecurityScanner.ts[39m
    â”œâ”€â”€ [33mrenderers[39m
    â”‚   â”œâ”€â”€ [33mConsoleRenderer.ts[39m
    â”‚   â”œâ”€â”€ [33mJsonRenderer.ts[39m
    â”‚   â””â”€â”€ [33mRenderer.ts[39m
    â”œâ”€â”€ [33msecurity[39m
    â”‚   â””â”€â”€ [33mGitIgnoreIntegration.ts[39m
    â”œâ”€â”€ [33mtree[39m
    â”‚   â”œâ”€â”€ [33mTreeCLI.ts[39m
    â”‚   â””â”€â”€ [33mTreeView.ts[39m
    â””â”€â”€ [33mtypes[39m
        â”œâ”€â”€ [33mchalk.d.ts[39m
        â”œâ”€â”€ [33mexpress.d.ts[39m
        â”œâ”€â”€ [33mfast-glob.d.ts[39m
        â”œâ”€â”€ [33mindex.ts[39m
        â””â”€â”€ [33mother-modules.d.ts[39m

[33m--- File: src/FileContextBuilder.ts (Size: 2642 bytes, 93 lines) ---[39m
import { FileCollector } from './collector/FileCollector';
import { FileCollectorConfig, FileContext } from './types';
import { ConsoleRenderer } from './renderers/ConsoleRenderer';
import { JsonRenderer } from './renderers/JsonRenderer';

export class FileContextBuilder {
  protected config: FileCollectorConfig;
  protected collector: FileCollector;

  constructor(config: FileCollectorConfig = {}) {
    this.config = config;
    this.collector = new FileCollector(this.config);
  }

  /**
   * Build context with files
   * @param format Optional output format (uses configured renderer if not specified)
   * @returns File context with collected files
   */
  public async build(format?: string): Promise<FileContext> {
    // Collect files
    const files = await this.collector.collectFiles();

    // Create base context
    const context: FileContext = {
      config: this.config,
      files,
      totalFiles: files.length,
      totalSize: files.reduce((sum, file) => sum + (file.fileSize || 0), 0)
    };

    // Render output if format is specified
    if (format) {
      context.output = await this.renderOutput(context, format);
    }

    return context;
  }

  /**
   * Build context with a custom renderer
   * @param renderer Custom renderer to use
   * @returns File context with rendered output
   */
  public async buildWithRenderer(renderer: any): Promise<FileContext> {
    const context = await this.build();
    context.output = await this.renderWithCustomRenderer(context, renderer);
    return context;
  }

  /**
   * Get current configuration
   * @returns Current configuration
   */
  public getConfig(): FileCollectorConfig {
    return this.config;
  }

  /**
   * Set new configuration
   * @param config New configuration
   */
  public setConfig(config: FileCollectorConfig): void {
    this.config = config;
    this.collector = new FileCollector(this.config);
  }

  /**
   * Render output with a specific format
   * @param context File context
   * @param format Output format
   * @returns Rendered output
   */
  protected async renderOutput(context: FileContext, format: string): Promise<string> {
    switch (format.toLowerCase()) {
      case 'json':
        return new JsonRenderer().render(context);
      case 'console':
      default:
        return new ConsoleRenderer().render(context);
    }
  }

  /**
   * Render with a custom renderer
   * @param context File context
   * @param renderer Custom renderer
   * @returns Rendered output
   */
  protected async renderWithCustomRenderer(context: FileContext, renderer: any): Promise<string> {
    return renderer.render(context);
  }
}

[33m--- File: src/index.ts (Size: 550 bytes, 10 lines) ---[39m
export { FileContextBuilder } from "./FileContextBuilder";
export * from "./types";
export * from "./renderers/Renderer";
export { ConsoleRenderer } from "./renderers/ConsoleRenderer";
export { JsonRenderer, FileContextJson } from "./renderers/JsonRenderer";
export { FileCollectorConfig } from "./types";
export { WhitelistBlacklist } from "./collector/WhitelistBlacklist";
export { FileContentSearch, FileSearchOptions, FileSearchResult } from "./collector/FileContentSearch";
export { RegexPatternMatcher } from "./collector/RegexPatternMatcher";


[33m--- File: src/cli/index.ts (Size: 16694 bytes, 454 lines) ---[39m
#!/usr/bin/env node

import { Command } from 'commander';
import chalk from 'chalk';
import * as path from 'path';
import * as fs from 'fs';
import { 
  FileContextBuilder, 
  FileCollectorConfig,
  ConsoleRenderer,
  JsonRenderer,
  WhitelistBlacklist,
  FileContentSearch,
  FileSearchOptions,
  RegexPatternMatcher
} from '../index';

// Get package version from package.json
const packageJson = JSON.parse(
  fs.readFileSync(path.join(__dirname, '../../package.json'), 'utf8')
);

const program = new Command();

program
  .name('contextr')
  .description('A lightweight library that packages your project\'s code files into structured context for LLMs')
  .version(packageJson.version);

program
  .command('build')
  .description('Build context from your project files')
  .option('-c, --config <path>', 'Path to configuration file')
  .option('-o, --output <path>', 'Output file path')
  .option('-f, --format <format>', 'Output format (console, json)', 'console')
  .option('-d, --dir <directories...>', 'Directories to include (comma-separated patterns)')
  .option('-i, --include <patterns...>', 'File patterns to include')
  .option('-e, --exclude <patterns...>', 'File patterns to exclude')
  .option('-r, --regex', 'Use regex for pattern matching', false)
  .option('-n, --name <n>', 'Context name', 'Project Context')
  .option('--no-contents', 'Don\'t show file contents')
  .option('--no-meta', 'Don\'t show metadata')
  .option('--ext <extensions...>', 'Filter by file extensions (e.g., js,ts,md)')
  .option('--search <pattern>', 'Only include files containing this pattern')
  .option('--search-regex', 'Use regex for search pattern', false)
  .option('--whitelist <patterns...>', 'Whitelist patterns (alternative to include)')
  .option('--blacklist <patterns...>', 'Blacklist patterns (alternative to exclude)')
  .action(async (options) => {
    try {
      let config: FileCollectorConfig;

      // Load from config file if provided
      if (options.config) {
        const configPath = path.resolve(options.config);
        if (!fs.existsSync(configPath)) {
          console.error(chalk.red(`Error: Config file not found: ${configPath}`));
          process.exit(1);
        }
        config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      } else {
        // Build config from command line options
        config = {
          name: options.name,
          showContents: options.contents !== false,
          showMeta: options.meta !== false,
          includeDirs: [],
          includeFiles: [],
          excludeFiles: [],
          useRegex: options.regex
        };

        // Add directories
        if (options.dir) {
          const dirs = Array.isArray(options.dir) ? options.dir : [options.dir];
          dirs.forEach((dirStr: string) => {
            const dirParts = dirStr.split(':');
            const dirPath = dirParts[0];
            const patterns = dirParts.length > 1 ? dirParts[1].split(',') : ['**/*'];
            
            config.includeDirs!.push({
              path: dirPath,
              include: patterns,
              recursive: true,
              useRegex: options.regex
            });
          });
        }

        // Add include files (or whitelist)
        if (options.include || options.whitelist) {
          const includes = options.include 
            ? (Array.isArray(options.include) ? options.include : [options.include])
            : (Array.isArray(options.whitelist) ? options.whitelist : [options.whitelist]);
          config.includeFiles = includes;
        }

        // Add exclude files (or blacklist)
        if (options.exclude || options.blacklist) {
          const excludes = options.exclude
            ? (Array.isArray(options.exclude) ? options.exclude : [options.exclude])
            : (Array.isArray(options.blacklist) ? options.blacklist : [options.blacklist]);
          config.excludeFiles = excludes;
        }
        
        // Add search in files option
        if (options.search) {
          config.searchInFiles = {
            pattern: options.search,
            isRegex: options.searchRegex || false
          };
        }
      }

      console.log(chalk.blue('Building context...'));
      const builder = new FileContextBuilder(config);
      let context = await builder.build();
      
      // Filter by file extensions if specified
      if (options.ext) {
        const extensions = Array.isArray(options.ext) 
          ? options.ext 
          : options.ext.split(',').map((ext: string) => ext.trim());
        
        const filteredFiles = context.files.filter(file => {
          const fileExt = path.extname(file.filePath).substring(1); // Remove the dot
          return extensions.includes(fileExt);
        });
        
        console.log(chalk.blue(`Filtered to ${filteredFiles.length} files with extensions: ${extensions.join(', ')}`));
        context.files = filteredFiles;
      }

      let output: string;
      if (options.format === 'json') {
        const jsonRenderer = new JsonRenderer();
        const jsonOutput = jsonRenderer.render(context);
        output = JSON.stringify(jsonOutput, null, 2);
      } else {
        const consoleRenderer = new ConsoleRenderer();
        output = consoleRenderer.render(context);
      }

      if (options.output) {
        const outputPath = path.resolve(options.output);
        fs.writeFileSync(outputPath, output);
        console.log(chalk.green(`Context written to ${outputPath}`));
      } else {
        console.log(output);
      }
    } catch (error) {
      console.error(chalk.red('Error building context:'), error);
      process.exit(1);
    }
  });

program
  .command('search')
  .description('Search for content within files')
  .option('-p, --pattern <pattern>', 'Search pattern')
  .option('-d, --dir <directories...>', 'Directories to search in')
  .option('-i, --include <patterns...>', 'File patterns to include')
  .option('-e, --exclude <patterns...>', 'File patterns to exclude')
  .option('-r, --regex', 'Use regex for pattern matching', false)
  .option('-c, --case-sensitive', 'Case sensitive search', false)
  .option('-w, --whole-word', 'Match whole words only', false)
  .option('--context <lines>', 'Number of context lines', '2')
  .option('-o, --output <path>', 'Output file path')
  .option('-f, --format <format>', 'Output format (text, json, files-only, count)', 'text')
  .option('--ext <extensions...>', 'Filter by file extensions (e.g., js,ts,md)')
  .option('--no-highlight', 'Disable match highlighting')
  .option('--max-results <number>', 'Maximum number of results to return', '100')
  .action(async (options) => {
    try {
      if (!options.pattern) {
        console.error(chalk.red('Error: Search pattern is required'));
        process.exit(1);
      }

      // Build config for file collection
      const config: FileCollectorConfig = {
        name: 'Search Context',
        showContents: true,
        showMeta: false,
        includeDirs: [],
        includeFiles: [],
        excludeFiles: [],
        useRegex: options.regex
      };

      // Add directories
      if (options.dir) {
        const dirs = Array.isArray(options.dir) ? options.dir : [options.dir];
        dirs.forEach((dirStr: string) => {
          const dirParts = dirStr.split(':');
          const dirPath = dirParts[0];
          const patterns = dirParts.length > 1 ? dirParts[1].split(',') : ['**/*'];
          
          config.includeDirs!.push({
            path: dirPath,
            include: patterns,
            recursive: true,
            useRegex: options.regex
          });
        });
      } else {
        // Default to current directory if none specified
        config.includeDirs!.push({
          path: '.',
          include: ['**/*'],
          recursive: true,
          useRegex: options.regex
        });
      }

      // Add include files
      if (options.include) {
        const includes = Array.isArray(options.include) ? options.include : [options.include];
        config.includeFiles = includes;
      }

      // Add exclude files
      if (options.exclude) {
        const excludes = Array.isArray(options.exclude) ? options.exclude : [options.exclude];
        config.excludeFiles = excludes;
      }

      console.log(chalk.blue('Collecting files...'));
      const builder = new FileContextBuilder(config);
      const context = await builder.build();
      
      // Filter by file extensions if specified
      let filesToSearch = context.files;
      if (options.ext) {
        const extensions = Array.isArray(options.ext) 
          ? options.ext 
          : options.ext.split(',').map((ext: string) => ext.trim());
        
        filesToSearch = context.files.filter(file => {
          const fileExt = path.extname(file.filePath).substring(1); // Remove the dot
          return extensions.includes(fileExt);
        });
        
        console.log(chalk.blue(`Filtered to ${filesToSearch.length} files with extensions: ${extensions.join(', ')}`));
      }

      console.log(chalk.blue(`Searching ${filesToSearch.length} files for: ${options.pattern}`));
      
      const searchOptions: FileSearchOptions = {
        pattern: options.pattern,
        isRegex: options.regex,
        caseSensitive: options.caseSensitive,
        wholeWord: options.wholeWord,
        contextLines: parseInt(options.context, 10),
        maxResults: parseInt(options.maxResults, 10)
      };

      // Handle different output formats
      switch (options.format.toLowerCase()) {
        case 'json': {
          const results = FileContentSearch.searchAsJson(filesToSearch, searchOptions);
          if (results.length === 0) {
            console.log(chalk.yellow('No matches found.'));
            return;
          }
          
          const jsonOutput = JSON.stringify(results, null, 2);
          if (options.output) {
            const outputPath = path.resolve(options.output);
            fs.writeFileSync(outputPath, jsonOutput);
            console.log(chalk.green(`Search results written to ${outputPath}`));
          } else {
            console.log(jsonOutput);
          }
          break;
        }
        
        case 'files-only': {
          const matchingFiles = FileContentSearch.searchForMatchingFiles(filesToSearch, searchOptions);
          if (matchingFiles.length === 0) {
            console.log(chalk.yellow('No matches found.'));
            return;
          }
          
          const output = matchingFiles.join('\n');
          if (options.output) {
            const outputPath = path.resolve(options.output);
            fs.writeFileSync(outputPath, output);
            console.log(chalk.green(`Matching files written to ${outputPath}`));
          } else {
            console.log(output);
          }
          break;
        }
        
        case 'count': {
          const totalMatches = FileContentSearch.countMatches(filesToSearch, searchOptions);
          const searchResults = FileContentSearch.searchInFiles(filesToSearch, searchOptions);
          const output = `Total matches: ${totalMatches}\nMatching files: ${searchResults.length}`;
          
          if (options.output) {
            const outputPath = path.resolve(options.output);
            fs.writeFileSync(outputPath, output);
            console.log(chalk.green(`Search count written to ${outputPath}`));
          } else {
            console.log(chalk.green(output));
          }
          break;
        }
        
        default: { // text format
          const searchResults = FileContentSearch.searchInFiles(filesToSearch, searchOptions);
          
          if (searchResults.length === 0) {
            console.log(chalk.yellow('No matches found.'));
            return;
          }

          console.log(chalk.green(`Found matches in ${searchResults.length} files.`));
          
          const formatOptions = {
            showFilePath: true,
            highlightMatches: options.highlight !== false
          };
          
          let resultsWithContext = searchResults;
          if (searchOptions.contextLines && searchOptions.contextLines > 0) {
            resultsWithContext = searchResults.map(result => 
              FileContentSearch.addContextLines(result, searchOptions.contextLines)
            );
          }
          
          const formattedResults = FileContentSearch.formatResults(
            resultsWithContext,
            formatOptions.showFilePath,
            formatOptions.highlightMatches
          );
          
          if (options.output) {
            const outputPath = path.resolve(options.output);
            fs.writeFileSync(outputPath, formattedResults);
            console.log(chalk.green(`Search results written to ${outputPath}`));
          } else {
            console.log(formattedResults);
          }
        }
      }
    } catch (error) {
      console.error(chalk.red('Error searching files:'), error);
      process.exit(1);
    }
  });

program
  .command('studio')
  .description('Launch the ContextR Studio UI')
  .option('-p, --port <port>', 'Port to run the studio on', '3000')
  .option('--host <host>', 'Host to bind to', 'localhost')
  .option('--open', 'Open browser automatically', false)
  .action((options) => {
    console.log(chalk.yellow(`ContextR Studio is launching on http://${options.host}:${options.port}...`));
    
    // Set environment variables for the studio
    process.env.CONTEXTR_STUDIO_PORT = options.port;
    process.env.CONTEXTR_STUDIO_HOST = options.host;
    process.env.CONTEXTR_STUDIO_OPEN_BROWSER = options.open ? 'true' : 'false';
    
    require('./studio');
  });

program
  .command('config')
  .description('Manage configuration presets')
  .option('--save <name>', 'Save current options as a preset')
  .option('--load <name>', 'Load a saved preset')
  .option('--list', 'List all saved presets')
  .option('--delete <name>', 'Delete a saved preset')
  .action((options) => {
    try {
      // Create config directory if it doesn't exist
      const configDir = path.join(process.env.HOME || process.env.USERPROFILE || '.', '.contextr');
      if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { recursive: true });
      }
      
      const presetsFile = path.join(configDir, 'presets.json');
      let presets = {};
      
      // Load existing presets if available
      if (fs.existsSync(presetsFile)) {
        presets = JSON.parse(fs.readFileSync(presetsFile, 'utf8'));
      }
      
      if (options.list) {
        console.log(chalk.blue('Saved presets:'));
        if (Object.keys(presets).length === 0) {
          console.log(chalk.yellow('No presets found.'));
        } else {
          Object.keys(presets).forEach(name => {
            console.log(`- ${name}`);
          });
        }
      } else if (options.save) {
        // Get all options from command line
        const preset = {
          // Capture relevant options here
          name: options.save,
          timestamp: new Date().toISOString()
        };
        
        presets[options.save] = preset;
        fs.writeFileSync(presetsFile, JSON.stringify(presets, null, 2));
        console.log(chalk.green(`Preset "${options.save}" saved successfully.`));
      } else if (options.load) {
        if (!presets[options.load]) {
          console.error(chalk.red(`Preset "${options.load}" not found.`));
          process.exit(1);
        }
        
        console.log(chalk.green(`Loaded preset "${options.load}".`));
        // Apply preset options
        // This would typically modify the command line args or set environment variables
      } else if (options.delete) {
        if (!presets[options.delete]) {
          console.error(chalk.red(`Preset "${options.delete}" not found.`));
          process.exit(1);
        }
        
        delete presets[options.delete];
        fs.writeFileSync(presetsFile, JSON.stringify(presets, null, 2));
        console.log(chalk.green(`Preset "${options.delete}" deleted successfully.`));
      } else {
        console.log(chalk.yellow('No action specified. Use --save, --load, --list, or --delete.'));
      }
    } catch (error) {
      console.error(chalk.red('Error managing configuration:'), error);
      process.exit(1);
    }
  });

// Handle unknown commands
program.on('command:*', () => {
  console.error(chalk.red(`Invalid command: ${(program as any).args?.join(' ') || 'unknown'}`));
  console.error('See --help for a list of available commands.');
  process.exit(1);
});

// Parse command line arguments
program.parse(process.argv);

// Show help if no arguments provided
if (process.argv.length === 2) {
  program.help();
}


[33m--- File: src/collector/FileCollector.ts (Size: 7441 bytes, 207 lines) ---[39m
import fastglob from "fast-glob";
import { promises as fs } from "fs";
import * as path from "path";
import { FileCollectorConfig, CollectedFile } from "../types";
import { RegexPatternMatcher } from "./RegexPatternMatcher";

export class FileCollector {
  private config: FileCollectorConfig;

  constructor(config: FileCollectorConfig) {
    this.config = config;
  }

  /**
   * Checks if a file path matches a pattern using either glob or regex
   * @param filePath The file path to check
   * @param pattern The pattern to match against
   * @param useRegex Whether to use regex matching instead of glob
   * @returns True if the file matches the pattern
   */
  private matchesPattern(filePath: string, pattern: string, useRegex: boolean): boolean {
    if (useRegex) {
      return RegexPatternMatcher.test(filePath, pattern);
    } else {
      // Use minimatch or similar for glob pattern matching
      // Fast-glob already handles this at directory level, but we need this for individual file checks
      return fastglob.isDynamicPattern(pattern) 
        ? fastglob.sync(pattern, { onlyFiles: true }).includes(filePath)
        : pattern === filePath;
    }
  }

  /**
   * Checks if a file should be excluded based on exclude patterns
   * @param filePath The file path to check
   * @param excludePatterns Array of patterns to exclude
   * @param useRegex Whether to use regex matching
   * @returns True if the file should be excluded
   */
  private shouldExcludeFile(filePath: string, excludePatterns: string[], useRegex: boolean): boolean {
    if (!excludePatterns || excludePatterns.length === 0) {
      return false;
    }
    
    return excludePatterns.some(pattern => 
      this.matchesPattern(filePath, pattern, useRegex)
    );
  }

  /**
   * Checks if file content matches the search pattern
   * @param content The file content to search in
   * @param searchPattern The pattern to search for
   * @param isRegex Whether to use regex for searching
   * @returns True if the content matches the search pattern
   */
  private contentMatchesSearch(content: string, searchPattern: string, isRegex: boolean): boolean {
    if (!searchPattern) {
      return true; // No search pattern means include all files
    }

    if (isRegex) {
      return RegexPatternMatcher.test(content, searchPattern, 'gm');
    } else {
      return content.includes(searchPattern);
    }
  }

  public async collectFiles(): Promise<CollectedFile[]> {
    const filePaths: Set<string> = new Set();
    const excludedPaths: Set<string> = new Set();

    // Process directories specified in includeDirs
    if (this.config.includeDirs) {
      for (const dirConfig of this.config.includeDirs) {
        const useRegex = dirConfig.useRegex ?? this.config.useRegex ?? false;
        
        // Handle include patterns
        if (useRegex) {
          // For regex, we need to get all files in the directory first, then filter
          const allFiles = await fastglob(path.join(dirConfig.path, '**/*'), {
            onlyFiles: true,
            deep: dirConfig.recursive ? Infinity : 1,
          });
          
          // Filter files using regex patterns
          for (const file of allFiles) {
            const shouldInclude = dirConfig.include.some(pattern => 
              this.matchesPattern(file, pattern, true)
            );
            
            if (shouldInclude) {
              filePaths.add(file);
            }
          }
        } else {
          // Use fast-glob for standard glob patterns
          const patterns = dirConfig.include.map((pattern) =>
            path.join(dirConfig.path, pattern),
          );
          const options = {
            onlyFiles: true,
            deep: dirConfig.recursive ? Infinity : 1,
          };
          const matches = await fastglob(patterns, options);
          matches.forEach((match: string) => filePaths.add(match));
        }
        
        // Handle exclude patterns if present
        if (dirConfig.exclude && dirConfig.exclude.length > 0) {
          // Get files that match exclude patterns
          if (useRegex) {
            // Filter out excluded files using regex
            for (const file of Array.from(filePaths)) {
              if (this.shouldExcludeFile(file, dirConfig.exclude, true)) {
                excludedPaths.add(file);
              }
            }
          } else {
            // Use fast-glob for standard glob exclude patterns
            const excludePatterns = dirConfig.exclude.map((pattern) =>
              path.join(dirConfig.path, pattern),
            );
            const excludedMatches = await fastglob(excludePatterns, {
              onlyFiles: true,
              deep: dirConfig.recursive ? Infinity : 1,
            });
            excludedMatches.forEach((match: string) => excludedPaths.add(match));
          }
        }
      }
    }

    // Process explicit include file paths
    if (this.config.includeFiles) {
      const useRegex = this.config.useRegex ?? false;
      
      if (useRegex) {
        // Get all files in current directory and subdirectories
        const allFiles = await fastglob('**/*', { onlyFiles: true });
        
        // Filter using regex patterns
        for (const file of allFiles) {
          const shouldInclude = this.config.includeFiles.some(pattern => 
            this.matchesPattern(file, pattern, true)
          );
          
          if (shouldInclude) {
            filePaths.add(file);
          }
        }
      } else {
        // Standard glob or direct file paths
        this.config.includeFiles.forEach((file) => filePaths.add(file));
      }
    }

    // Process explicit exclude file paths
    if (this.config.excludeFiles) {
      const useRegex = this.config.useRegex ?? false;
      
      if (useRegex) {
        // Filter out excluded files using regex
        for (const file of Array.from(filePaths)) {
          if (this.shouldExcludeFile(file, this.config.excludeFiles, true)) {
            excludedPaths.add(file);
          }
        }
      } else {
        // Use fast-glob for standard glob exclude patterns
        const excludedMatches = await fastglob(this.config.excludeFiles, { onlyFiles: true });
        excludedMatches.forEach((match: string) => excludedPaths.add(match));
      }
    }

    // Remove excluded paths from included paths
    for (const excludedPath of excludedPaths) {
      filePaths.delete(excludedPath);
    }

    const results: CollectedFile[] = [];
    for (const filePath of filePaths) {
      try {
        const content = await fs.readFile(filePath, "utf8");
        
        // Check if content matches search pattern if specified
        if (this.config.searchInFiles) {
          const { pattern, isRegex } = this.config.searchInFiles;
          if (!this.contentMatchesSearch(content, pattern, isRegex)) {
            continue; // Skip this file if content doesn't match search pattern
          }
        }
        
        const stats = await fs.stat(filePath);
        const fileSize = stats.size;
        const lineCount = content.split("\n").length;
        const absoluteFilePath = path.resolve(filePath);
        const relativePath = path.relative(process.cwd(), absoluteFilePath);
        results.push({ filePath, relativePath, content, fileSize, lineCount });
      } catch (err) {
        console.error(`Error reading file ${filePath}:`, err);
      }
    }
    return results;
  }
}


[33m--- File: src/collector/FileContentSearch.ts (Size: 9747 bytes, 300 lines) ---[39m
import { promises as fs } from "fs";
import * as path from "path";
import { CollectedFile } from "../types";
import { RegexPatternMatcher } from "./RegexPatternMatcher";

/**
 * Result of a file content search operation
 */
export interface FileSearchResult {
  file: CollectedFile;
  filePath?: string;
  content?: string;
  matches: {
    line: number;
    content: string;
    matchIndex: number;
    matchLength: number;
    contextContent?: string;
    contextStartLine?: number;
    contextEndLine?: number;
    beforeContext?: string;
    afterContext?: string;
  }[];
  matchCount: number;
}

/**
 * Options for file content search
 */
export interface FileSearchOptions {
  pattern: string;
  isRegex: boolean;
  caseSensitive: boolean;
  wholeWord: boolean;
  maxResults?: number;
  contextLines?: number;
}

/**
 * Helper class for searching content within files
 */
export class FileContentSearch {
  /**
   * Searches for content within a single file
   * @param file The file to search in
   * @param options Search options
   * @returns Search results with matches
   */
  public static searchInFile(file: CollectedFile, options: FileSearchOptions): FileSearchResult {
    const { pattern, isRegex, caseSensitive, wholeWord } = options;
    const lines = file.content.split('\n');
    const matches: FileSearchResult['matches'] = [];

    // Create regex pattern based on options
    let searchRegex: RegExp | null;

    if (isRegex) {
      // Use RegexPatternMatcher to handle pattern with flags
      const flags = caseSensitive ? 'g' : 'gi';
      searchRegex = RegexPatternMatcher.createRegex(pattern, flags);
    } else {
      // For plain text search
      let escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      if (wholeWord) {
        escapedPattern = `\\b${escapedPattern}\\b`;
      }
      const flags = caseSensitive ? 'g' : 'gi';
      searchRegex = new RegExp(escapedPattern, flags);
    }

    if (!searchRegex) {
      console.error(`Invalid search pattern: ${pattern}`);
      return { file, matches: [], matchCount: 0 };
    }

    // Search each line for matches
    lines.forEach((lineContent, lineIndex) => {
      let match;
      searchRegex!.lastIndex = 0; // Reset regex for each line

      while ((match = searchRegex!.exec(lineContent)) !== null) {
        matches.push({
          line: lineIndex + 1, // 1-based line numbers
          content: lineContent,
          matchIndex: match.index,
          matchLength: match[0].length
        });

        // Avoid infinite loops with zero-length matches
        if (match.index === searchRegex!.lastIndex) {
          searchRegex!.lastIndex++;
        }
      }
    });

    return {
      file,
      matches,
      matchCount: matches.length
    };
  }

  /**
   * Searches for content within multiple files
   * @param files Array of files to search in
   * @param options Search options
   * @returns Array of search results
   */
  public static searchInFiles(files: CollectedFile[], options: FileSearchOptions): FileSearchResult[] {
    const results = files
      .map(file => this.searchInFile(file, options))
      .filter(result => result.matchCount > 0);

    // Limit results if maxResults is specified
    if (options.maxResults && results.length > options.maxResults) {
      return results.slice(0, options.maxResults);
    }

    return results;
  }

  /**
   * Gets context lines around a match
   * @param result Search result
   * @param contextLines Number of context lines before and after match
   * @returns Search result with context lines added
   */
  public static addContextLines(result: FileSearchResult, contextLines: number = 2): FileSearchResult {
    if (contextLines <= 0) {
      return result;
    }

    const lines = result.file.content.split('\n');
    const matchesWithContext = result.matches.map(match => {
      // Use RegexPatternMatcher's findMatchesWithContext for more robust context extraction
      const lineIndex = match.line - 1; // Convert to 0-based for array access
      const lineContent = lines[lineIndex];

      const startLine = Math.max(0, lineIndex - contextLines);
      const endLine = Math.min(lines.length - 1, lineIndex + contextLines);

      // Add context lines to the match object
      const contextContent = lines.slice(startLine, endLine + 1).join('\n');
      const beforeContext = lines.slice(startLine, lineIndex).join('\n');
      const afterContext = lines.slice(lineIndex + 1, endLine + 1).join('\n');

      return {
        ...match,
        contextContent,
        contextStartLine: startLine + 1, // Convert back to 1-based
        contextEndLine: endLine + 1,    // Convert back to 1-based
        beforeContext,
        afterContext
      };
    });

    return {
      ...result,
      matches: matchesWithContext as any
    };
  }

  /**
   * Formats search results as a string
   * @param results Search results
   * @param showFilePath Whether to show file paths
   * @param highlightMatches Whether to highlight matches
   * @returns Formatted string with search results
   */
  public static formatResults(
    results: FileSearchResult[],
    showFilePath: boolean = true,
    highlightMatches: boolean = true
  ): string {
    let output = '';

    results.forEach(result => {
      if (showFilePath) {
        output += `\nFile: ${result.file.filePath} (${result.matchCount} matches)\n`;
        output += '='.repeat(result.file.filePath.length + 10) + '\n';
      }

      result.matches.forEach(match => {
        // Check if we have context content (from addContextLines)
        if (match.contextContent) {
          // Show line numbers for context
          output += `Lines ${match.contextStartLine}-${match.contextEndLine}:\n`;

          // Show before context if available
          if (match.beforeContext && match.beforeContext.length > 0) {
            output += match.beforeContext + '\n';
          }

          // Show the matching line with highlighting
          if (highlightMatches && match.matchIndex >= 0) {
            const beforeMatch = match.content.substring(0, match.matchIndex);
            const matchText = match.content.substring(match.matchIndex, match.matchIndex + match.matchLength);
            const afterMatch = match.content.substring(match.matchIndex + match.matchLength);

            output += `${beforeMatch}>>>${matchText}<<<${afterMatch}\n`;
            output += `Line ${match.line}: ` + ' '.repeat(match.matchIndex) + '^'.repeat(match.matchLength) + '\n';
          } else {
            output += `Line ${match.line}: ${match.content}\n`;
          }

          // Show after context if available
          if (match.afterContext && match.afterContext.length > 0) {
            output += match.afterContext + '\n';
          }
        } else {
          // Original behavior for results without context
          output += `Line ${match.line}: ${match.content}\n`;

          // Add a pointer to the match
          if (highlightMatches && match.matchIndex >= 0) {
            output += ' '.repeat(match.matchIndex + 7) + '^'.repeat(match.matchLength) + '\n';
          }
        }

        output += '\n';
      });
    });

    return output;
  }

  /**
   * Searches for content in files and returns formatted results
   * @param files Array of files to search in
   * @param options Search options
   * @param formatOptions Formatting options
   * @returns Formatted string with search results
   */
  public static search(
    files: CollectedFile[],
    options: FileSearchOptions,
    formatOptions: {
      showFilePath?: boolean,
      highlightMatches?: boolean
    } = {}
  ): string {
    const results = this.searchInFiles(files, options);

    if (options.contextLines && options.contextLines > 0) {
      const resultsWithContext = results.map(result =>
        this.addContextLines(result, options.contextLines)
      );
      return this.formatResults(
        resultsWithContext,
        formatOptions.showFilePath !== undefined ? formatOptions.showFilePath : true,
        formatOptions.highlightMatches !== undefined ? formatOptions.highlightMatches : true
      );
    }

    return this.formatResults(
      results,
      formatOptions.showFilePath !== undefined ? formatOptions.showFilePath : true,
      formatOptions.highlightMatches !== undefined ? formatOptions.highlightMatches : true
    );
  }

  /**
   * Searches for content in files and returns results as JSON
   * @param files Array of files to search in
   * @param options Search options
   * @returns JSON object with search results
   */
  public static searchAsJson(files: CollectedFile[], options: FileSearchOptions): any {
    const results = this.searchInFiles(files, options);

    if (options.contextLines && options.contextLines > 0) {
      return results.map(result => this.addContextLines(result, options.contextLines));
    }

    return results;
  }

  /**
   * Searches for content in files and returns only matching file paths
   * @param files Array of files to search in
   * @param options Search options
   * @returns Array of file paths that contain matches
   */
  public static searchForMatchingFiles(files: CollectedFile[], options: FileSearchOptions): string[] {
    const results = this.searchInFiles(files, options);
    return results.map(result => result.file.filePath);
  }

  /**
   * Counts matches across all files
   * @param files Array of files to search in
   * @param options Search options
   * @returns Total number of matches
   */
  public static countMatches(files: CollectedFile[], options: FileSearchOptions): number {
    const results = this.searchInFiles(files, options);
    return results.reduce((total, result) => total + result.matchCount, 0);
  }
}


[33m--- File: src/collector/ListOnlySupport.ts (Size: 4380 bytes, 135 lines) ---[39m
// Integration of list-only mode with FileCollector
// This file enhances the FileCollector to support list-only files

import * as path from 'path';
import * as fs from 'fs-extra';
import { FileCollectorConfig, CollectedFile } from '../types';
import { RegexPatternMatcher } from './RegexPatternMatcher';

/**
 * Enhanced file collector configuration with list-only support
 */
export interface EnhancedFileCollectorConfig extends FileCollectorConfig {
  /** Files to include in the tree but not their contents */
  listOnlyFiles?: string[];

  /** Patterns for files to include in the tree but not their contents */
  listOnlyPatterns?: string[];

  /** Whether to use regex for list-only patterns */
  useRegexForListOnly?: boolean;
}

/**
 * Check if a file should be list-only
 * @param filePath File path to check
 * @param config File collector configuration
 * @returns Whether the file should be list-only
 */
export function isListOnlyFile(filePath: string, config: EnhancedFileCollectorConfig): boolean {
  // Check explicit list-only files
  if (config.listOnlyFiles && config.listOnlyFiles.includes(filePath)) {
    return true;
  }

  // Check list-only patterns
  if (config.listOnlyPatterns && config.listOnlyPatterns.length > 0) {
    const matcher = new RegexPatternMatcher();

    for (const pattern of config.listOnlyPatterns) {
      if (config.useRegexForListOnly) {
        if (matcher.matchRegexPattern(filePath, pattern)) {
          return true;
        }
      } else {
        if (matcher.matchGlobPattern(filePath, pattern)) {
          return true;
        }
      }
    }
  }

  return false;
}

/**
 * Process a list-only file
 * @param filePath Path to the file
 * @returns Collected file with minimal content
 */
export async function processListOnlyFile(filePath: string): Promise<CollectedFile> {
  try {
    // Get file stats
    const stats = await fs.stat(filePath);

    // Get file extension
    const extension = path.extname(filePath).toLowerCase();

    // Create placeholder content based on file type
    let placeholderContent = '';
    let fileType = '';

    // Determine file type and create appropriate placeholder
    if (['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'].includes(extension)) {
      fileType = 'image';
      placeholderContent = `[Image file: ${path.basename(filePath)}]`;
    } else if (['.mp4', '.avi', '.mov', '.wmv', '.flv', '.mkv'].includes(extension)) {
      fileType = 'video';
      placeholderContent = `[Video file: ${path.basename(filePath)}]`;
    } else if (['.mp3', '.wav', '.ogg', '.flac', '.aac'].includes(extension)) {
      fileType = 'audio';
      placeholderContent = `[Audio file: ${path.basename(filePath)}]`;
    } else if (['.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx'].includes(extension)) {
      fileType = 'document';
      placeholderContent = `[Document file: ${path.basename(filePath)}]`;
    } else if (['.zip', '.rar', '.tar', '.gz', '.7z'].includes(extension)) {
      fileType = 'archive';
      placeholderContent = `[Archive file: ${path.basename(filePath)}]`;
    } else if (['.exe', '.dll', '.so', '.dylib'].includes(extension)) {
      fileType = 'binary';
      placeholderContent = `[Binary file: ${path.basename(filePath)}]`;
    } else {
      fileType = 'unknown';
      placeholderContent = `[File: ${path.basename(filePath)} (list-only)]`;
    }

    // Create collected file
    return {
      filePath,
      content: placeholderContent,
      meta: {
        size: stats.size,
        lastModified: stats.mtime.getTime(),
        type: fileType,
        isListOnly: true
      }
    };
  } catch (error) {
    console.error(`Error processing list-only file ${filePath}:`, error);

    // Return minimal information on error
    return {
      filePath,
      content: `[Error: Could not process file ${path.basename(filePath)}]`,
      meta: {
        isListOnly: true,
        error: error instanceof Error ? error.message : String(error)
      }
    };
  }
}

/**
 * Enhance a file collector configuration with list-only support
 * @param config Original configuration
 * @returns Enhanced configuration
 */
export function enhanceConfigWithListOnly(config: FileCollectorConfig): EnhancedFileCollectorConfig {
  return {
    ...config,
    listOnlyFiles: [],
    listOnlyPatterns: [],
    useRegexForListOnly: config.useRegex
  };
}


[33m--- File: src/collector/RegexPatternMatcher.ts (Size: 8420 bytes, 258 lines) ---[39m
import { FileCollectorConfig } from "../types";

/**
 * Enhanced regex pattern matching utility for contextr
 */
export class RegexPatternMatcher {
  /**
   * Parses a pattern string to extract regex pattern and flags
   * @param pattern The pattern string (e.g., "pattern:i" for case-insensitive)
   * @param defaultFlags Default flags to use if none specified
   * @returns Object containing the pattern and flags
   */
  /**
   * Alias for parsePatternWithFlags for backward compatibility
   */
  public static parseRegexPattern(pattern: string, defaultFlags: string = ''): { pattern: string, flags: string } {
    return this.parsePatternWithFlags(pattern, defaultFlags);
  }

  public static parsePatternWithFlags(pattern: string, defaultFlags: string = ''): { pattern: string, flags: string } {
    let flags = defaultFlags;
    const patternParts = pattern.split(':');

    if (patternParts.length > 1) {
      const lastPart = patternParts.pop() || '';
      // Check if the last part contains only valid regex flags
      if (/^[gimsuy]+$/.test(lastPart)) {
        flags = lastPart;
        pattern = patternParts.join(':');
      } else {
        // If not valid flags, restore the original pattern
        pattern = patternParts.join(':') + ':' + lastPart;
      }
    }

    return { pattern, flags };
  }

  /**
   * Creates a RegExp object from a pattern string with optional flags
   * @param pattern The pattern string
   * @param defaultFlags Default flags to use if none specified
   * @returns RegExp object or null if invalid
   */
  public static createRegex(pattern: string, defaultFlags: string = ''): RegExp | null {
    try {
      const { pattern: parsedPattern, flags } = this.parsePatternWithFlags(pattern, defaultFlags);
      return new RegExp(parsedPattern, flags);
    } catch (err) {
      console.error(`Invalid regex pattern: ${pattern}`, err);
      return null;
    }
  }

  /**
   * Tests if a string matches a regex pattern
   * @param str The string to test
   * @param pattern The pattern to match against
   * @param defaultFlags Default flags to use if none specified
   * @returns True if the string matches the pattern
   */
  public static test(str: string, pattern: string, defaultFlags: string = ''): boolean {
    const regex = this.createRegex(pattern, defaultFlags);
    return regex ? regex.test(str) : false;
  }

  /**
   * Finds all matches of a pattern in a string
   * @param str The string to search in
   * @param pattern The pattern to search for
   * @param defaultFlags Default flags to use (will ensure 'g' flag is included)
   * @returns Array of matches or empty array if no matches or invalid pattern
   */
  public static findMatches(str: string, pattern: string, defaultFlags: string = 'g'): RegExpMatchArray[] {
    // Ensure global flag is present
    const ensuredFlags = defaultFlags.includes('g') ? defaultFlags : defaultFlags + 'g';
    const regex = this.createRegex(pattern, ensuredFlags);
    if (!regex) return [];

    const matches: RegExpMatchArray[] = [];
    let match: RegExpMatchArray | null;

    while ((match = regex.exec(str)) !== null) {
      matches.push(match);
    }

    return matches;
  }

  /**
   * Match a file path against a regex pattern
   * @param filePath The file path to match
   * @param pattern The regex pattern to match against
   * @returns True if the file path matches the pattern
   */
  public matchRegexPattern(filePath: string, pattern: string): boolean {
    return RegexPatternMatcher.matchRegexPattern(filePath, pattern);
  }

  /**
   * Match a file path against a glob pattern
   * @param filePath The file path to match
   * @param pattern The glob pattern to match against
   * @returns True if the file path matches the pattern
   */
  public matchGlobPattern(filePath: string, pattern: string): boolean {
    return RegexPatternMatcher.matchGlobPattern(filePath, pattern);
  }

  /**
   * Static method to match a file path against a regex pattern
   * @param filePath The file path to match
   * @param pattern The regex pattern to match against
   * @returns True if the file path matches the pattern
   */
  public static matchRegexPattern(filePath: string, pattern: string): boolean {
    try {
      const { pattern: regexPattern, flags } = this.parsePatternWithFlags(pattern);
      const regex = new RegExp(regexPattern, flags);
      return regex.test(filePath);
    } catch (error) {
      console.warn(`Invalid regex pattern: ${pattern}`);
      return false;
    }
  }

  /**
   * Static method to match a file path against a glob pattern
   * @param filePath The file path to match
   * @param pattern The glob pattern to match against
   * @returns True if the file path matches the pattern
   */
  public static matchGlobPattern(filePath: string, pattern: string): boolean {
    // Simple glob pattern matching implementation
    // Convert glob pattern to regex
    const regexPattern = pattern
      .replace(/\./g, '\\.')
      .replace(/\*/g, '.*')
      .replace(/\?/g, '.')
      .replace(/\[\!([^\]]+)\]/g, '[^$1]');

    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(filePath);
  }

  /**
   * Alias for findMatchesWithContext for backward compatibility
   */
  public static getMatchesWithContext(content: string, pattern: string, contextLines: number = 0): any[] {
    return this.findMatchesWithContext(content, pattern, contextLines);
  }

  /**
   * Alias for findMatches for backward compatibility
   */
  public static getMatches(content: string, pattern: string): RegExpMatchArray[] {
    return this.findMatches(content, pattern);
  }

  /**
   * Get matches with line numbers
   */
  public static getMatchesWithLineNumbers(content: string, pattern: string): any[] {
    const lines = content.split('\n');
    const { pattern: regexPattern, flags } = this.parsePatternWithFlags(pattern);
    const regex = new RegExp(regexPattern, flags);

    const matches: Array<{match: string, line: number, content: string}> = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const lineMatches = line.match(regex);

      if (lineMatches) {
        for (const match of lineMatches) {
          matches.push({
            match,
            line: i + 1,
            content: line
          });
        }
      }
    }

    return matches;
  }

  /**
   * Extracts context lines around matches in a string
   * @param str The string to search in
   * @param pattern The pattern to search for
   * @param contextLines Number of lines before and after the match to include
   * @param defaultFlags Default flags to use
   * @returns Array of match contexts with line numbers
   */
  public static findMatchesWithContext(
    str: string,
    pattern: string,
    contextLines: number = 2,
    defaultFlags: string = 'gm'
  ): Array<{
    match: string,
    lineNumber: number,
    context: string,
    beforeLines: number,
    afterLines: number
  }> {
    const lines = str.split('\n');
    const regex = this.createRegex(pattern, defaultFlags);
    if (!regex) return [];

    const results: Array<{
      match: string,
      lineNumber: number,
      context: string,
      beforeLines: number,
      afterLines: number
    }> = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (regex.test(line)) {
        // Reset regex lastIndex
        regex.lastIndex = 0;

        // Calculate context line ranges
        const startLine = Math.max(0, i - contextLines);
        const endLine = Math.min(lines.length - 1, i + contextLines);

        // Extract context
        const contextArray = lines.slice(startLine, endLine + 1);
        const context = contextArray.join('\n');

        results.push({
          match: line,
          lineNumber: i + 1, // 1-based line number
          context,
          beforeLines: i - startLine,
          afterLines: endLine - i
        });
      }
    }

    return results;
  }

  /**
   * Filters an array of strings based on a regex pattern
   * @param strings Array of strings to filter
   * @param pattern The pattern to match against
   * @param defaultFlags Default flags to use
   * @returns Filtered array of strings that match the pattern
   */
  public static filterStrings(strings: string[], pattern: string, defaultFlags: string = ''): string[] {
    return strings.filter(str => this.test(str, pattern, defaultFlags));
  }
}


[33m--- File: src/collector/WhitelistBlacklist.ts (Size: 6797 bytes, 215 lines) ---[39m
import * as path from "path";
import fastglob from "fast-glob";
import { FileCollectorConfig } from "../types";
import { RegexPatternMatcher } from "./RegexPatternMatcher";

/**
 * Helper class for managing whitelist and blacklist functionality
 */
export class WhitelistBlacklist {
  /**
   * Creates a whitelist configuration from a list of patterns
   * @param patterns Array of file patterns to include
   * @param useRegex Whether to use regex matching
   * @returns A partial FileCollectorConfig with whitelist settings
   */
  public static createWhitelist(patterns: string[], useRegex = false): Partial<FileCollectorConfig> {
    return {
      includeFiles: patterns,
      useRegex
    };
  }

  /**
   * Creates a blacklist configuration from a list of patterns
   * @param patterns Array of file patterns to exclude
   * @param useRegex Whether to use regex matching
   * @returns A partial FileCollectorConfig with blacklist settings
   */
  public static createBlacklist(patterns: string[], useRegex = false): Partial<FileCollectorConfig> {
    return {
      excludeFiles: patterns,
      useRegex
    };
  }

  /**
   * Merges a whitelist and blacklist configuration
   * @param whitelist Whitelist configuration
   * @param blacklist Blacklist configuration
   * @returns A merged FileCollectorConfig
   */
  public static mergeConfigs(
    whitelist: Partial<FileCollectorConfig>, 
    blacklist: Partial<FileCollectorConfig>
  ): Partial<FileCollectorConfig> {
    return {
      includeFiles: whitelist.includeFiles,
      excludeFiles: blacklist.excludeFiles,
      useRegex: whitelist.useRegex || blacklist.useRegex
    };
  }

  /**
   * Creates a combined configuration with both directory and file patterns
   * @param dirPatterns Directory patterns to include
   * @param filePatterns File patterns to include
   * @param excludePatterns Patterns to exclude
   * @param useRegex Whether to use regex matching
   * @returns A complete FileCollectorConfig
   */
  public static createConfig(
    dirPatterns: string[] = [],
    filePatterns: string[] = [],
    excludePatterns: string[] = [],
    useRegex = false
  ): Partial<FileCollectorConfig> {
    const config: Partial<FileCollectorConfig> = {
      useRegex
    };
    
    if (dirPatterns.length > 0) {
      config.includeDirs = dirPatterns.map(dirPattern => ({
        path: path.dirname(dirPattern) || '.',
        include: [path.basename(dirPattern)],
        recursive: true,
        useRegex
      }));
    }
    
    if (filePatterns.length > 0) {
      config.includeFiles = filePatterns;
    }
    
    if (excludePatterns.length > 0) {
      config.excludeFiles = excludePatterns;
    }
    
    return config;
  }

  /**
   * Checks if a file path is in the whitelist
   * @param filePath File path to check
   * @param patterns Whitelist patterns
   * @param useRegex Whether to use regex matching
   * @returns True if the file is in the whitelist
   */
  public static isInWhitelist(filePath: string, patterns: string[], useRegex = false): boolean {
    if (!patterns || patterns.length === 0) {
      return true; // Empty whitelist means include everything
    }

    if (useRegex) {
      return patterns.some(pattern => RegexPatternMatcher.test(filePath, pattern));
    } else {
      // Use fast-glob for standard glob patterns
      return patterns.some(pattern => {
        if (fastglob.isDynamicPattern(pattern)) {
          return fastglob.sync(pattern, { onlyFiles: true }).includes(filePath);
        } else {
          return pattern === filePath;
        }
      });
    }
  }

  /**
   * Checks if a file path is in the blacklist
   * @param filePath File path to check
   * @param patterns Blacklist patterns
   * @param useRegex Whether to use regex matching
   * @returns True if the file is in the blacklist
   */
  public static isInBlacklist(filePath: string, patterns: string[], useRegex = false): boolean {
    if (!patterns || patterns.length === 0) {
      return false; // Empty blacklist means exclude nothing
    }

    return this.isInWhitelist(filePath, patterns, useRegex); // Reuse the same logic
  }

  /**
   * Filters a list of file paths using whitelist and blacklist patterns
   * @param filePaths Array of file paths to filter
   * @param whitelist Whitelist patterns
   * @param blacklist Blacklist patterns
   * @param useRegex Whether to use regex matching
   * @returns Filtered array of file paths
   */
  public static filterPaths(
    filePaths: string[], 
    whitelist: string[] = [], 
    blacklist: string[] = [], 
    useRegex = false
  ): string[] {
    return filePaths.filter(filePath => 
      this.isInWhitelist(filePath, whitelist, useRegex) && 
      !this.isInBlacklist(filePath, blacklist, useRegex)
    );
  }

  /**
   * Filters file paths based on file extension
   * @param filePaths Array of file paths to filter
   * @param extensions Array of file extensions to include (without the dot)
   * @returns Filtered array of file paths
   */
  public static filterByExtension(filePaths: string[], extensions: string[]): string[] {
    if (!extensions || extensions.length === 0) {
      return filePaths;
    }
    
    return filePaths.filter(filePath => {
      const ext = path.extname(filePath).toLowerCase().substring(1); // Remove the dot
      return extensions.includes(ext);
    });
  }

  /**
   * Filters file paths based on directory
   * @param filePaths Array of file paths to filter
   * @param directories Array of directories to include
   * @param includeSubdirs Whether to include subdirectories
   * @returns Filtered array of file paths
   */
  public static filterByDirectory(
    filePaths: string[], 
    directories: string[], 
    includeSubdirs = true
  ): string[] {
    if (!directories || directories.length === 0) {
      return filePaths;
    }
    
    return filePaths.filter(filePath => {
      const dir = path.dirname(filePath);
      
      return directories.some(directory => {
        if (includeSubdirs) {
          // Check if the file is in the directory or any subdirectory
          return dir === directory || dir.startsWith(directory + path.sep);
        } else {
          // Check if the file is directly in the directory
          return dir === directory;
        }
      });
    });
  }

  /**
   * Creates a pattern that matches files with specific content
   * @param contentPattern Pattern to match in file content
   * @param isRegex Whether the pattern is a regex
   * @returns A FileSearchOptions object for content-based filtering
   */
  public static createContentFilter(contentPattern: string, isRegex = false): { searchInFiles: { pattern: string, isRegex: boolean } } {
    return {
      searchInFiles: {
        pattern: contentPattern,
        isRegex
      }
    };
  }
}


[33m--- File: src/plugins/PluginCLI.ts (Size: 7830 bytes, 246 lines) ---[39m
// Plugin system CLI integration
// This file extends the CLI to support plugin commands and options

import { Command } from 'commander';
import { pluginManager } from './PluginManager';
import { PluginEnabledFileContextBuilder } from './PluginEnabledFileContextBuilder';
import chalk from 'chalk';

/**
 * Register plugin-related commands with the CLI
 * @param program Commander program instance
 */
export function registerPluginCommands(program: Command): void {
  // Add plugins command
  const pluginsCommand = program
    .command('plugins')
    .description('Manage plugins');

  // List plugins
  pluginsCommand
    .command('list')
    .description('List installed plugins')
    .option('-t, --type <type>', 'Filter by plugin type (security-scanner, output-renderer, llm-reviewer)')
    .option('-j, --json', 'Output as JSON')
    .action(async (options) => {
      try {
        await pluginManager.loadPlugins();

        let plugins = pluginManager.getAllPlugins();

        // Filter by type if specified
        if (options.type) {
          plugins = plugins.filter(p => p.type === options.type);
        }

        if (options.json) {
          console.log(JSON.stringify(plugins, null, 2));
          return;
        }

        if (plugins.length === 0) {
          console.log('No plugins installed.');
          return;
        }

        console.log(chalk.bold('Installed plugins:'));

        // Group by type
        const byType = plugins.reduce((acc, plugin) => {
          if (!acc[plugin.type]) {
            acc[plugin.type] = [];
          }
          acc[plugin.type].push(plugin);
          return acc;
        }, {} as Record<string, any[]>);

        for (const [type, typePlugins] of Object.entries(byType)) {
          console.log(chalk.cyan(`\n${formatPluginType(type)}:`));

          for (const plugin of typePlugins) {
            console.log(`  ${chalk.green(plugin.name)} (${plugin.id}) v${plugin.version}`);
            console.log(`    ${plugin.description}`);
          }
        }
      } catch (error) {
        console.error(chalk.red('Error listing plugins:'), error instanceof Error ? error.message : String(error));
        process.exit(1);
      }
    });

  // Add plugin options to build command
  program.commands.forEach(cmd => {
    if (cmd.name() === 'build') {
      cmd
        .option('--enable-plugins', 'Enable plugin system')
        .option('--security-scanners <ids>', 'Security scanner plugin IDs to use (comma-separated)')
        .option('--output-renderer <id>', 'Output renderer plugin ID to use')
        .option('--llm-reviewers <ids>', 'LLM reviewer plugin IDs to use (comma-separated)')
        .option('--generate-security-report', 'Generate security reports')
        .option('--generate-summaries', 'Generate summaries using LLM reviewers')
        .option('--security-report-file <file>', 'File to write security report to')
        .option('--summaries-file <file>', 'File to write summaries to');
    }
  });

  // Add plugin options to search command
  program.commands.forEach(cmd => {
    if (cmd.name() === 'search') {
      cmd
        .option('--enable-plugins', 'Enable plugin system')
        .option('--security-scanners <ids>', 'Security scanner plugin IDs to use (comma-separated)')
        .option('--output-renderer <id>', 'Output renderer plugin ID to use');
    }
  });
}

/**
 * Apply plugin options from CLI to config
 * @param config Configuration object
 * @param options CLI options
 */
export function applyPluginOptions(config: any, options: any): void {
  if (options.enablePlugins) {
    config.enablePlugins = true;
  }

  if (options.securityScanners) {
    config.securityScanners = options.securityScanners.split(',');
  }

  if (options.outputRenderer) {
    config.outputRenderer = options.outputRenderer;
  }

  if (options.llmReviewers) {
    config.llmReviewers = options.llmReviewers.split(',');
  }

  if (options.generateSecurityReport) {
    config.generateSecurityReports = true;
  }

  if (options.generateSummaries) {
    config.generateSummaries = true;
  }
}

/**
 * Handle plugin-specific output from build result
 * @param result Build result
 * @param options CLI options
 */
export async function handlePluginOutput(result: any, options: any): Promise<void> {
  // Write security reports to file if specified
  if (options.securityReportFile && result.securityReports && result.securityReports.length > 0) {
    const fs = require('fs-extra');
    await fs.writeJson(options.securityReportFile, result.securityReports, { spaces: 2 });
    console.log(chalk.green(`Security reports written to ${options.securityReportFile}`));
  }

  // Write summaries to file if specified
  if (options.summariesFile && result.summaries && Object.keys(result.summaries).length > 0) {
    const fs = require('fs-extra');
    await fs.writeJson(options.summariesFile, result.summaries, { spaces: 2 });
    console.log(chalk.green(`Summaries written to ${options.summariesFile}`));
  }

  // Display security issues in console
  if (result.securityReports && result.securityReports.length > 0) {
    console.log(chalk.yellow('\nSecurity issues found:'));

    let totalIssues = 0;

    for (const report of result.securityReports) {
      console.log(chalk.cyan(`\n${report.scannerId}:`));

      if (report.issues.length === 0) {
        console.log('  No issues found');
        continue;
      }

      totalIssues += report.issues.length;

      // Group by severity
      const bySeverity = report.issues.reduce((acc, issue) => {
        if (!acc[issue.severity]) {
          acc[issue.severity] = [];
        }
        acc[issue.severity].push(issue);
        return acc;
      }, {} as Record<string, any[]>);

      // Display issues by severity (critical first)
      const severities = ['critical', 'error', 'warning', 'info'];

      for (const severity of severities) {
        if (bySeverity[severity]) {
          const color = getSeverityColor(severity);
          console.log(`  ${color(severity.toUpperCase())} (${bySeverity[severity].length}):`);

          // Limit to 5 issues per severity to avoid overwhelming output
          const issuesToShow = bySeverity[severity].slice(0, 5);
          const remaining = bySeverity[severity].length - issuesToShow.length;

          for (const issue of issuesToShow) {
            console.log(`    ${issue.filePath}${issue.lineNumber ? `:${issue.lineNumber}` : ''}`);
            console.log(`      ${issue.description}`);
          }

          if (remaining > 0) {
            console.log(`    ... and ${remaining} more ${severity} issues`);
          }
        }
      }
    }

    console.log(chalk.yellow(`\nTotal security issues: ${totalIssues}`));
  }

  // Display summaries
  if (result.summaries && Object.keys(result.summaries).length > 0) {
    console.log(chalk.yellow('\nSummaries:'));

    for (const [reviewerId, summary] of Object.entries(result.summaries)) {
      console.log(chalk.cyan(`\n${reviewerId}:`));
      console.log(summary);
    }
  }
}

/**
 * Format plugin type for display
 * @param type Plugin type
 */
function formatPluginType(type: string): string {
  switch (type) {
    case 'security-scanner':
      return 'Security Scanners';
    case 'output-renderer':
      return 'Output Renderers';
    case 'llm-reviewer':
      return 'LLM Reviewers';
    default:
      return type.charAt(0).toUpperCase() + type.slice(1);
  }
}

/**
 * Get color function for severity
 * @param severity Severity level
 */
function getSeverityColor(severity: string): (text: string) => string {
  switch (severity) {
    case 'critical':
      return chalk.red.bold;
    case 'error':
      return chalk.red;
    case 'warning':
      return chalk.yellow;
    case 'info':
      return chalk.blue;
    default:
      return chalk.white;
  }
}


[33m--- File: src/plugins/PluginEnabledFileContextBuilder.ts (Size: 6486 bytes, 234 lines) ---[39m
// Plugin system integration with FileContextBuilder
// This file extends the core FileContextBuilder to support plugins

import { FileContextBuilder } from '../FileContextBuilder';
import { CollectedFile, FileCollectorConfig, FileContext } from '../types';
import { pluginManager, PluginType } from './PluginManager';

/**
 * Extended configuration for FileContextBuilder with plugin support
 */
export interface PluginEnabledConfig extends FileCollectorConfig {
  /** Enable or disable plugin system */
  enablePlugins?: boolean;

  /** Security scanner plugin IDs to use (all available if not specified) */
  securityScanners?: string[];

  /** Output renderer plugin ID to use */
  outputRenderer?: string;

  /** LLM reviewer plugin IDs to use (all available if not specified) */
  llmReviewers?: string[];

  /** Configuration for security scanners */
  securityScannerConfig?: any;

  /** Configuration for output renderers */
  outputRendererConfig?: any;

  /** Configuration for LLM reviewers */
  llmReviewerConfig?: any;

  /** Generate security reports */
  generateSecurityReports?: boolean;

  /** Generate summaries using LLM reviewers */
  generateSummaries?: boolean;
}

/**
 * Extended build result with plugin-generated data
 */
export interface PluginEnabledBuildResult {
  /** Original files */
  files: CollectedFile[];

  /** Rendered output */
  output: string;

  /** Security reports (if generated) */
  securityReports?: any[];

  /** Summaries generated by LLM reviewers (if generated) */
  summaries?: Record<string, string>;

  /** Total number of files */
  totalFiles: number;

  /** Total size of all files */
  totalSize: number;
}

/**
 * Extension of FileContextBuilder with plugin support
 */
export class PluginEnabledFileContextBuilder extends FileContextBuilder {
  private pluginConfig: PluginEnabledConfig;

  /**
   * Create a new plugin-enabled file context builder
   * @param config Configuration
   */
  constructor(config: PluginEnabledConfig = {}) {
    super(config);
    this.pluginConfig = config;
  }

  /**
   * Build context with plugin support
   * @param format Output format
   * @returns Build result with plugin-generated data
   */
  async build(format?: string): Promise<FileContext> {
    format = format || 'console';
    // Get base result from parent class
    const baseResult = await super.build(format);

    // If plugins are disabled, return base result
    if (this.pluginConfig.enablePlugins === false) {
      // Add security reports and summaries to the base result
      const result = baseResult as any;
      result.securityReports = [];
      result.summaries = {};
      if (!result.output) result.output = '';
      return result;
    }

    let files = baseResult.files;
    let output = baseResult.output;
    const securityReports: any[] = [];
    const summaries: Record<string, string> = {};

    try {
      // Load plugins if not already loaded
      await this.ensurePluginsLoaded();

      // Run security scanners
      if (pluginManager.getSecurityScanners().length > 0) {
        files = await pluginManager.runSecurityScanners(
          files,
          this.pluginConfig.securityScanners,
          this.pluginConfig.securityScannerConfig
        );

        // Generate security reports if requested
        if (this.pluginConfig.generateSecurityReports) {
          const reports = await pluginManager.generateSecurityReports(
            files,
            this.pluginConfig.securityScanners,
            this.pluginConfig.securityScannerConfig
          );
          securityReports.push(...reports);
        }
      }

      // Run LLM reviewers
      if (pluginManager.getLLMReviewers().length > 0) {
        files = await pluginManager.reviewFiles(
          files,
          this.pluginConfig.llmReviewers,
          this.pluginConfig.llmReviewerConfig
        );

        // Generate summaries if requested
        if (this.pluginConfig.generateSummaries) {
          const generatedSummaries = await pluginManager.generateSummaries(
            files,
            this.pluginConfig.llmReviewers,
            this.pluginConfig.llmReviewerConfig
          );
          Object.assign(summaries, generatedSummaries);
        }
      }

      // Use custom output renderer if specified
      if (this.pluginConfig.outputRenderer) {
        try {
          output = await pluginManager.renderOutput(
            files,
            this.pluginConfig.outputRenderer,
            this.pluginConfig.outputRendererConfig
          );
        } catch (error) {
          console.error(`Error using output renderer ${this.pluginConfig.outputRenderer}:`, error);
          // Fall back to original output
        }
      }
    } catch (error) {
      console.error('Error using plugins:', error);
      // Continue with base result on error
    }

    // Create the result object
    const result = {
      files,
      config: this.config,
      output,
      totalFiles: files.length,
      totalSize: files.reduce((sum, file) => sum + (file.meta?.size || 0), 0)
    } as any;

    // Add plugin-specific properties
    result.securityReports = securityReports;
    result.summaries = summaries;

    return result;
  }

  /**
   * Ensure plugins are loaded
   */
  private async ensurePluginsLoaded(): Promise<void> {
    // Check if any plugins are loaded
    if (pluginManager.getAllPlugins().length === 0) {
      await pluginManager.loadPlugins();
    }
  }

  /**
   * Get available plugin information
   */
  async getAvailablePlugins() {
    await this.ensurePluginsLoaded();

    return {
      securityScanners: pluginManager.getSecurityScanners().map(p => ({
        id: p.id,
        name: p.name,
        version: p.version,
        description: p.description
      })),
      outputRenderers: pluginManager.getOutputRenderers().map(p => ({
        id: p.id,
        name: p.name,
        version: p.version,
        description: p.description,
        formatName: p.getFormatName()
      })),
      llmReviewers: pluginManager.getLLMReviewers().map(p => ({
        id: p.id,
        name: p.name,
        version: p.version,
        description: p.description
      }))
    };
  }

  /**
   * Get configuration
   */
  getConfig(): PluginEnabledConfig {
    return this.pluginConfig;
  }

  /**
   * Set configuration
   * @param config New configuration
   */
  setConfig(config: PluginEnabledConfig): void {
    super.setConfig(config);
    this.pluginConfig = config;
  }
}


[33m--- File: src/plugins/PluginManager.ts (Size: 12826 bytes, 492 lines) ---[39m
// Plugin system architecture for contextr
// This file defines the core plugin interfaces and management system

import * as path from 'path';
import * as fs from 'fs-extra';
import { CollectedFile, FileCollectorConfig } from '../types';

/**
 * Plugin types supported by the system
 */
export enum PluginType {
  SECURITY_SCANNER = 'security-scanner',
  OUTPUT_RENDERER = 'output-renderer',
  LLM_REVIEWER = 'llm-reviewer'
}

/**
 * Base interface for all plugins
 */
export interface Plugin {
  /** Unique identifier for the plugin */
  id: string;

  /** Human-readable name of the plugin */
  name: string;

  /** Plugin type */
  type: PluginType;

  /** Plugin version */
  version: string;

  /** Plugin description */
  description: string;

  /** Initialize the plugin */
  initialize?(): Promise<void>;

  /** Clean up resources when plugin is disabled */
  cleanup?(): Promise<void>;
}

/**
 * Security scanner plugin interface
 */
export interface SecurityScannerPlugin extends Plugin {
  type: PluginType.SECURITY_SCANNER;

  /**
   * Scan files for security issues
   * @param files Files to scan
   * @param config Configuration for the scanner
   * @returns Files with security warnings added to metadata
   */
  scanFiles(files: CollectedFile[], config?: any): Promise<CollectedFile[]>;

  /**
   * Get security warnings as a separate report
   * @param files Files to scan
   * @param config Configuration for the scanner
   * @returns Security report
   */
  generateSecurityReport?(files: CollectedFile[], config?: any): Promise<SecurityReport>;
}

/**
 * Output renderer plugin interface
 */
export interface OutputRendererPlugin extends Plugin {
  type: PluginType.OUTPUT_RENDERER;

  /**
   * Render files to a specific output format
   * @param files Files to render
   * @param config Configuration for the renderer
   * @returns Rendered output
   */
  render(files: CollectedFile[], config?: any): Promise<string>;

  /**
   * Get the format name for this renderer
   */
  getFormatName(): string;
}

/**
 * LLM reviewer plugin interface
 */
export interface LLMReviewerPlugin extends Plugin {
  type: PluginType.LLM_REVIEWER;

  /**
   * Review files using an LLM
   * @param files Files to review
   * @param config Configuration for the reviewer
   * @returns Reviewed files with additional metadata
   */
  reviewFiles(files: CollectedFile[], config?: any): Promise<CollectedFile[]>;

  /**
   * Generate a summary of the files
   * @param files Files to summarize
   * @param config Configuration for the summarizer
   * @returns Summary text
   */
  generateSummary?(files: CollectedFile[], config?: any): Promise<string>;

  /**
   * Check if the LLM is available (e.g., model is downloaded)
   */
  isAvailable(): Promise<boolean>;
}

/**
 * Security issue severity levels
 */
export enum SecurityIssueSeverity {
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error',
  CRITICAL = 'critical'
}

/**
 * Security issue found in a file
 */
export interface SecurityIssue {
  /** File path where the issue was found */
  filePath: string;

  /** Line number where the issue was found (1-based) */
  lineNumber?: number;

  /** Issue severity */
  severity: SecurityIssueSeverity;

  /** Issue description */
  description: string;

  /** Suggested remediation */
  remediation?: string;

  /** Raw content that triggered the issue (may be redacted for sensitive data) */
  content?: string;
}

/**
 * Security report generated by a scanner
 */
export interface SecurityReport {
  /** Scanner that generated the report */
  scannerId: string;

  /** Issues found */
  issues: SecurityIssue[];

  /** Summary of findings */
  summary: {
    totalFiles: number;
    filesWithIssues: number;
    issuesBySeverity: Record<SecurityIssueSeverity, number>;
  };
}

/**
 * Plugin manager for loading and managing plugins
 */
export class PluginManager {
  private plugins: Map<string, Plugin> = new Map();
  private securityScanners: Map<string, SecurityScannerPlugin> = new Map();
  private outputRenderers: Map<string, OutputRendererPlugin> = new Map();
  private llmReviewers: Map<string, LLMReviewerPlugin> = new Map();

  /**
   * Create a new plugin manager
   * @param pluginsDir Directory where plugins are located
   */
  constructor(private pluginsDir: string = '') {
    // Default to plugins directory in user's home directory
    if (!this.pluginsDir) {
      this.pluginsDir = path.join(process.env.HOME || process.env.USERPROFILE || '', '.contextr', 'plugins');
    }
  }

  /**
   * Load all plugins from the plugins directory
   */
  async loadPlugins(): Promise<void> {
    // Create plugins directory if it doesn't exist
    await fs.ensureDir(this.pluginsDir);

    // Get all subdirectories in the plugins directory
    const pluginDirs = await fs.readdir(this.pluginsDir);

    for (const dir of pluginDirs) {
      const pluginDir = path.join(this.pluginsDir, dir);
      const stat = await fs.stat(pluginDir);

      if (stat.isDirectory()) {
        try {
          await this.loadPlugin(pluginDir);
        } catch (error) {
          console.error(`Failed to load plugin from ${pluginDir}:`, error);
        }
      }
    }

    console.log(`Loaded ${this.plugins.size} plugins`);
  }

  /**
   * Load a plugin from a directory
   * @param pluginDir Directory containing the plugin
   */
  async loadPlugin(pluginDir: string): Promise<void> {
    const indexPath = path.join(pluginDir, 'index.js');

    if (!await fs.pathExists(indexPath)) {
      throw new Error(`Plugin index.js not found in ${pluginDir}`);
    }

    try {
      // Load the plugin
      const pluginModule = require(indexPath);
      const plugin = pluginModule.default || pluginModule;

      // Validate plugin
      if (!plugin.id || !plugin.name || !plugin.type || !plugin.version) {
        throw new Error(`Invalid plugin format: missing required fields`);
      }

      // Initialize plugin if needed
      if (plugin.initialize) {
        await plugin.initialize();
      }

      // Register plugin
      this.registerPlugin(plugin);

    } catch (error) {
      throw new Error(`Failed to load plugin: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Register a plugin with the manager
   * @param plugin Plugin to register
   */
  registerPlugin(plugin: Plugin): void {
    // Check if plugin with this ID is already registered
    if (this.plugins.has(plugin.id)) {
      throw new Error(`Plugin with ID ${plugin.id} is already registered`);
    }

    // Add to general plugins map
    this.plugins.set(plugin.id, plugin);

    // Add to type-specific map
    switch (plugin.type) {
      case PluginType.SECURITY_SCANNER:
        this.securityScanners.set(plugin.id, plugin as SecurityScannerPlugin);
        break;
      case PluginType.OUTPUT_RENDERER:
        this.outputRenderers.set(plugin.id, plugin as OutputRendererPlugin);
        break;
      case PluginType.LLM_REVIEWER:
        this.llmReviewers.set(plugin.id, plugin as LLMReviewerPlugin);
        break;
      default:
        console.warn(`Unknown plugin type: ${plugin.type}`);
    }

    console.log(`Registered plugin: ${plugin.name} (${plugin.id})`);
  }

  /**
   * Get all registered plugins
   */
  getAllPlugins(): Plugin[] {
    return Array.from(this.plugins.values());
  }

  /**
   * Get all security scanner plugins
   */
  getSecurityScanners(): SecurityScannerPlugin[] {
    return Array.from(this.securityScanners.values());
  }

  /**
   * Get all output renderer plugins
   */
  getOutputRenderers(): OutputRendererPlugin[] {
    return Array.from(this.outputRenderers.values());
  }

  /**
   * Get all LLM reviewer plugins
   */
  getLLMReviewers(): LLMReviewerPlugin[] {
    return Array.from(this.llmReviewers.values());
  }

  /**
   * Get a plugin by ID
   * @param id Plugin ID
   */
  getPlugin(id: string): Plugin | undefined {
    return this.plugins.get(id);
  }

  /**
   * Get a security scanner plugin by ID
   * @param id Plugin ID
   */
  getSecurityScanner(id: string): SecurityScannerPlugin | undefined {
    return this.securityScanners.get(id);
  }

  /**
   * Get an output renderer plugin by ID
   * @param id Plugin ID
   */
  getOutputRenderer(id: string): OutputRendererPlugin | undefined {
    return this.outputRenderers.get(id);
  }

  /**
   * Get an LLM reviewer plugin by ID
   * @param id Plugin ID
   */
  getLLMReviewer(id: string): LLMReviewerPlugin | undefined {
    return this.llmReviewers.get(id);
  }

  /**
   * Run security scanners on files
   * @param files Files to scan
   * @param scannerIds IDs of scanners to use (all if not specified)
   * @param config Configuration for scanners
   */
  async runSecurityScanners(
    files: CollectedFile[],
    scannerIds?: string[],
    config?: any
  ): Promise<CollectedFile[]> {
    let result = [...files];

    const scanners = scannerIds
      ? scannerIds.map(id => this.getSecurityScanner(id)).filter(Boolean) as SecurityScannerPlugin[]
      : this.getSecurityScanners();

    for (const scanner of scanners) {
      result = await scanner.scanFiles(result, config);
    }

    return result;
  }

  /**
   * Generate security reports for files
   * @param files Files to scan
   * @param scannerIds IDs of scanners to use (all if not specified)
   * @param config Configuration for scanners
   */
  async generateSecurityReports(
    files: CollectedFile[],
    scannerIds?: string[],
    config?: any
  ): Promise<SecurityReport[]> {
    const reports: SecurityReport[] = [];

    const scanners = scannerIds
      ? scannerIds.map(id => this.getSecurityScanner(id)).filter(Boolean) as SecurityScannerPlugin[]
      : this.getSecurityScanners();

    for (const scanner of scanners) {
      if (scanner.generateSecurityReport) {
        const report = await scanner.generateSecurityReport(files, config);
        reports.push(report);
      }
    }

    return reports;
  }

  /**
   * Render files using an output renderer
   * @param files Files to render
   * @param rendererId ID of renderer to use
   * @param config Configuration for renderer
   */
  async renderOutput(
    files: CollectedFile[],
    rendererId: string,
    config?: any
  ): Promise<string> {
    const renderer = this.getOutputRenderer(rendererId);

    if (!renderer) {
      throw new Error(`Output renderer with ID ${rendererId} not found`);
    }

    return await renderer.render(files, config);
  }

  /**
   * Review files using LLM reviewers
   * @param files Files to review
   * @param reviewerIds IDs of reviewers to use (all if not specified)
   * @param config Configuration for reviewers
   */
  async reviewFiles(
    files: CollectedFile[],
    reviewerIds?: string[],
    config?: any
  ): Promise<CollectedFile[]> {
    let result = [...files];

    const reviewers = reviewerIds
      ? reviewerIds.map(id => this.getLLMReviewer(id)).filter(Boolean) as LLMReviewerPlugin[]
      : this.getLLMReviewers();

    for (const reviewer of reviewers) {
      // Check if reviewer is available
      const available = await reviewer.isAvailable();
      if (!available) {
        console.warn(`LLM reviewer ${reviewer.id} is not available, skipping`);
        continue;
      }

      result = await reviewer.reviewFiles(result, config);
    }

    return result;
  }

  /**
   * Generate summaries for files using LLM reviewers
   * @param files Files to summarize
   * @param reviewerIds IDs of reviewers to use (all if not specified)
   * @param config Configuration for reviewers
   */
  async generateSummaries(
    files: CollectedFile[],
    reviewerIds?: string[],
    config?: any
  ): Promise<Record<string, string>> {
    const summaries: Record<string, string> = {};

    const reviewers = reviewerIds
      ? reviewerIds.map(id => this.getLLMReviewer(id)).filter(Boolean) as LLMReviewerPlugin[]
      : this.getLLMReviewers();

    for (const reviewer of reviewers) {
      // Check if reviewer is available and has generateSummary method
      const available = await reviewer.isAvailable();
      if (!available || !reviewer.generateSummary) {
        continue;
      }

      const summary = await reviewer.generateSummary(files, config);
      summaries[reviewer.id] = summary;
    }

    return summaries;
  }

  /**
   * Unload and clean up all plugins
   */
  async unloadPlugins(): Promise<void> {
    for (const [id, plugin] of this.plugins.entries()) {
      try {
        if (plugin.cleanup) {
          await plugin.cleanup();
        }
      } catch (error) {
        console.error(`Error cleaning up plugin ${id}:`, error);
      }
    }

    this.plugins.clear();
    this.securityScanners.clear();
    this.outputRenderers.clear();
    this.llmReviewers.clear();
  }
}

// Export a singleton instance
export const pluginManager = new PluginManager();


[33m--- File: src/renderers/ConsoleRenderer.ts (Size: 3907 bytes, 112 lines) ---[39m
// src/renderers/ConsoleRenderer.ts
import * as path from 'path';
import chalk from 'chalk';
import { FileContext } from '../types';
import { Renderer } from './Renderer';

interface TreeNode {
  name: string;
  children: TreeNode[];
  isFile: boolean;
  filePath?: string;
  fileSize?: number;
}

export class ConsoleRenderer implements Renderer<string> {
  render(context: FileContext): string {
    let output = "";
    const config = context.config;
    const files = context.files;

    // Render meta: Directory Tree
    if (config.showMeta) {
      output += chalk.bold.blue("=== Directory Tree ===") + "\n";
      const tree = this.buildTree(files);
      output += chalk.bold(tree.name) + "\n";
      output += this.getTreeString(tree, "");
      output += "\n";
    }

    // Render file contents
    if (config.showContents) {
      for (const file of files) {
        if (config.showMeta) {
          output += chalk.yellow(
            `--- File: ${file.filePath} (Size: ${file.fileSize} bytes, ${file.lineCount} lines) ---`
          ) + "\n";
        }
        output += file.content + "\n";
        if (config.showMeta) {
          output += "\n";
        }
      }
    }

    // Render summary with Included Files and Statistics sections.
    if (config.showMeta) {
      output += chalk.bold.blue("=== Summary ===") + "\n";

      // Included Files Section: list every file with its metadata.
      output += "\n" + chalk.bold.magenta("Included Files:") + "\n";
      files.forEach((file) => {
        output += `  ${chalk.cyan(file.filePath)} - ${chalk.green(
          file.fileSize + " bytes"
        )}, ${chalk.green(file.lineCount + " lines")}\n`;
      });

      // Statistics Section: compute overall stats based on file content.
      const totalFiles = files.length;
      const totalLines = files.reduce((sum, file) => sum + (file.lineCount || 0), 0);
      const totalSize = files.reduce((sum, file) => sum + (file.fileSize || 0), 0);
      const totalChars = files.reduce((sum, file) => sum + file.content.length, 0);
      // A rough heuristic: 1 token â‰ˆ 4 characters.
      const estimatedTokens = Math.round(totalChars / 4);

      output += "\n" + chalk.bold.magenta("Statistics:") + "\n";
      output += `  ${chalk.green("Total files:")} ${chalk.cyan(totalFiles.toString())}\n`;
      output += `  ${chalk.green("Total lines:")} ${chalk.cyan(totalLines.toString())}\n`;
      output += `  ${chalk.green("Total size:")} ${chalk.cyan(totalSize.toString() + " bytes")}\n`;
      output += `  ${chalk.green("Estimated tokens:")} ${chalk.cyan(estimatedTokens.toString())}\n`;
    }

    return output;
  }

  private buildTree(files: FileContext["files"]): TreeNode {
    const root: TreeNode = { name: ".", children: [], isFile: false };
    for (const file of files) {
      const parts = (file.relativePath || file.filePath).split(path.sep);
      let currentNode = root;
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        let child = currentNode.children.find((n) => n.name === part);
        if (!child) {
          child = {
            name: part,
            children: [],
            isFile: i === parts.length - 1,
          };
          if (child.isFile) {
            child.filePath = file.filePath;
            child.fileSize = file.fileSize;
          }
          currentNode.children.push(child);
        }
        currentNode = child;
      }
    }
    return root;
  }

  private getTreeString(node: TreeNode, prefix: string): string {
    let str = "";
    const children = node.children;
    const lastIndex = children.length - 1;
    children.forEach((child, index) => {
      const isLast = index === lastIndex;
      str += prefix + (isLast ? "â””â”€â”€ " : "â”œâ”€â”€ ") + chalk.yellow(child.name) + "\n";
      str += this.getTreeString(child, prefix + (isLast ? "    " : "â”‚   "));
    });
    return str;
  }
}

[33m--- File: src/renderers/JsonRenderer.ts (Size: 1627 bytes, 61 lines) ---[39m
// src/renderers/JsonRenderer.ts
import { FileContext } from '../types';
import { Renderer } from './Renderer';

export interface FileContextJson {
  fileContext: FileContext;
  summary: {
    includedFiles: {
      filePath: string;
      fileSize: number;
      lineCount: number;
    }[];
    statistics: {
      totalFiles: number;
      totalLines: number;
      totalSize: number;
      estimatedTokens: number;
    };
  };
}

export class JsonRenderer implements Renderer {
  /**
   * Returns the rendered output as a string.
   */
  render(context: FileContext): string {
    const jsonData = this.renderToObject(context);
    return JSON.stringify(jsonData, null, 2);
  }

  /**
   * Returns the rendered output as a typed object.
   */
  renderToObject(context: FileContext): FileContextJson {
    const includedFiles = context.files.map(file => ({
      filePath: file.filePath,
      fileSize: file.fileSize || 0,
      lineCount: file.lineCount || 0,
    }));

    const totalFiles = context.files.length;
    const totalLines = context.files.reduce((sum, file) => sum + (file.lineCount || 0), 0);
    const totalSize = context.files.reduce((sum, file) => sum + (file.fileSize || 0), 0);
    const totalChars = context.files.reduce((sum, file) => sum + file.content.length, 0);
    // A rough heuristic: 1 token â‰ˆ 4 characters.
    const estimatedTokens = Math.round(totalChars / 4);

    return {
      fileContext: context,
      summary: {
        includedFiles,
        statistics: {
          totalFiles,
          totalLines,
          totalSize,
          estimatedTokens,
        },
      },
    };
  }
}

[33m--- File: src/renderers/Renderer.ts (Size: 147 bytes, 6 lines) ---[39m
// src/renderers/Renderer.ts
import { FileContext } from '../types';

export interface Renderer<T = unknown> {
  render(context: FileContext): T;
}

[33m--- File: src/security/GitIgnoreIntegration.ts (Size: 8079 bytes, 262 lines) ---[39m
// GitIgnore Security Scanner Integration
// This file integrates the GitIgnore security scanner with the file collector

import * as path from 'path';
import * as fs from 'fs-extra';
import { GitIgnoreSecurityScanner } from '../plugins/security-scanners/GitIgnoreSecurityScanner';
import { FileCollectorConfig, CollectedFile, SecurityIssueSeverity, PluginEnabledConfig } from '../types';

/**
 * Configuration for GitIgnore integration
 */
export interface GitIgnoreIntegrationConfig {
  /** Whether to use .gitignore files for security scanning (default: true) */
  useGitIgnore?: boolean;

  /** Additional .gitignore files to use */
  additionalGitIgnoreFiles?: string[];

  /** Whether to treat .gitignore matches as security issues (default: true) */
  treatGitIgnoreAsSecurityIssue?: boolean;

  /** Whether to automatically exclude files matched by .gitignore (default: false) */
  autoExcludeGitIgnoreMatches?: boolean;

  /** Whether to scan for sensitive patterns in files not excluded by .gitignore (default: true) */
  scanNonGitIgnoredFiles?: boolean;
}

/**
 * Integrate GitIgnore security scanner with file collector
 * @param config File collector configuration
 * @param gitIgnoreConfig GitIgnore integration configuration
 * @returns Enhanced file collector configuration
 */
export async function integrateGitIgnoreSecurity(
  config: FileCollectorConfig,
  gitIgnoreConfig: GitIgnoreIntegrationConfig = {}
): Promise<FileCollectorConfig> {
  // Apply defaults
  const effectiveConfig = {
    useGitIgnore: gitIgnoreConfig.useGitIgnore !== false,
    additionalGitIgnoreFiles: gitIgnoreConfig.additionalGitIgnoreFiles || [],
    treatGitIgnoreAsSecurityIssue: gitIgnoreConfig.treatGitIgnoreAsSecurityIssue !== false,
    autoExcludeGitIgnoreMatches: gitIgnoreConfig.autoExcludeGitIgnoreMatches || false,
    scanNonGitIgnoredFiles: gitIgnoreConfig.scanNonGitIgnoredFiles !== false
  };

  // Skip if not using GitIgnore
  if (!effectiveConfig.useGitIgnore) {
    return config;
  }

  // Create GitIgnore scanner
  const scanner = new GitIgnoreSecurityScanner();
  await scanner.initialize();

  // Find project root (directory containing .git)
  let projectRoot = process.cwd();
  let currentDir = projectRoot;
  let foundGit = false;

  while (currentDir !== path.parse(currentDir).root) {
    if (await fs.pathExists(path.join(currentDir, '.git'))) {
      projectRoot = currentDir;
      foundGit = true;
      break;
    }
    currentDir = path.dirname(currentDir);
  }

  if (!foundGit) {
    console.warn('No .git directory found, using current directory as project root');
  }

  // Find all .gitignore files
  const gitIgnoreFiles = [
    path.join(projectRoot, '.gitignore'),
    ...effectiveConfig.additionalGitIgnoreFiles
  ].filter(async file => await fs.pathExists(file));

  // Load .gitignore patterns
  await scanner.loadGitIgnoreFiles(gitIgnoreFiles);

  // Create enhanced config
  const enhancedConfig = { ...config };

  // Auto-exclude files matched by .gitignore if requested
  if (effectiveConfig.autoExcludeGitIgnoreMatches) {
    // Get all files that would be included
    const allFiles: string[] = [];

    if (config.includeFiles) {
      allFiles.push(...config.includeFiles);
    }

    if (config.includeDirs) {
      for (const dir of config.includeDirs) {
        const files = await getAllFilesInDir(dir.path);
        allFiles.push(...files);
      }
    }

    // Filter out files matched by .gitignore
    const filteredFiles = allFiles.filter(file => !scanner.isIgnored(file));

    // Update config
    enhancedConfig.includeFiles = filteredFiles;
    enhancedConfig.includeDirs = [];
  }

  // Convert to PluginEnabledConfig
  const pluginConfig = enhancedConfig as unknown as PluginEnabledConfig;

  // Add scanner to security scanners
  if (!pluginConfig.securityScanners) {
    pluginConfig.securityScanners = [];
  }

  // Add a custom scanner function
  const gitignoreScanner = {
    name: 'gitignore',
    scan: async (file: CollectedFile): Promise<CollectedFile> => {
      // Skip if file is already excluded
      if (effectiveConfig.autoExcludeGitIgnoreMatches) {
        return file;
      }

      // Check if file is ignored by .gitignore
      const isIgnored = scanner.isIgnored(file.filePath);

      // Add security issue if ignored and configured to treat as security issue
      if (isIgnored && effectiveConfig.treatGitIgnoreAsSecurityIssue) {
        if (!file.meta) {
          file.meta = {};
        }

        if (!file.meta.securityIssues) {
          file.meta.securityIssues = [];
        }

        file.meta.securityIssues.push({
          description: 'File matches .gitignore pattern',
          severity: SecurityIssueSeverity.WARNING,
          details: 'This file would be ignored by Git, which may indicate it contains sensitive information or should not be included in the context.'
        });
      }

      return file;
    }
  };

  // Add the scanner to the array
  pluginConfig.securityScanners.push(gitignoreScanner as any);

  return enhancedConfig;
}

/**
 * Get all files in a directory recursively
 * @param dir Directory to scan
 * @returns Array of file paths
 */
async function getAllFilesInDir(dir: string): Promise<string[]> {
  const result: string[] = [];

  async function scanDir(currentDir: string) {
    const entries = await fs.readdir(currentDir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(currentDir, entry.name);

      if (entry.isDirectory()) {
        await scanDir(fullPath);
      } else {
        result.push(fullPath);
      }
    }
  }

  await scanDir(dir);
  return result;
}

/**
 * Apply GitIgnore security scanner to collected files
 * @param files Collected files
 * @param gitIgnoreConfig GitIgnore integration configuration
 * @returns Enhanced collected files
 */
export async function applyGitIgnoreSecurity(
  files: CollectedFile[],
  gitIgnoreConfig: GitIgnoreIntegrationConfig = {}
): Promise<CollectedFile[]> {
  // Apply defaults
  const effectiveConfig = {
    useGitIgnore: gitIgnoreConfig.useGitIgnore !== false,
    additionalGitIgnoreFiles: gitIgnoreConfig.additionalGitIgnoreFiles || [],
    treatGitIgnoreAsSecurityIssue: gitIgnoreConfig.treatGitIgnoreAsSecurityIssue !== false
  };

  // Skip if not using GitIgnore
  if (!effectiveConfig.useGitIgnore) {
    return files;
  }

  // Create GitIgnore scanner
  const scanner = new GitIgnoreSecurityScanner();
  await scanner.initialize();

  // Find project root (directory containing .git)
  let projectRoot = process.cwd();
  let currentDir = projectRoot;
  let foundGit = false;

  while (currentDir !== path.parse(currentDir).root) {
    if (await fs.pathExists(path.join(currentDir, '.git'))) {
      projectRoot = currentDir;
      foundGit = true;
      break;
    }
    currentDir = path.dirname(currentDir);
  }

  if (!foundGit) {
    console.warn('No .git directory found, using current directory as project root');
  }

  // Find all .gitignore files
  const gitIgnoreFiles = [
    path.join(projectRoot, '.gitignore'),
    ...effectiveConfig.additionalGitIgnoreFiles
  ].filter(async file => await fs.pathExists(file));

  // Load .gitignore patterns
  await scanner.loadGitIgnoreFiles(gitIgnoreFiles);

  // Process each file
  return Promise.all(files.map(async (file) => {
    // Check if file is ignored by .gitignore
    const isIgnored = scanner.isIgnored(file.filePath);

    // Add security issue if ignored and configured to treat as security issue
    if (isIgnored && effectiveConfig.treatGitIgnoreAsSecurityIssue) {
      if (!file.meta) {
        file.meta = {};
      }

      if (!file.meta.securityIssues) {
        file.meta.securityIssues = [];
      }

      file.meta.securityIssues.push({
        description: 'File matches .gitignore pattern',
        severity: SecurityIssueSeverity.WARNING,
        details: 'This file would be ignored by Git, which may indicate it contains sensitive information or should not be included in the context.'
      });
    }

    return file;
  }));
}


[33m--- File: src/tree/TreeCLI.ts (Size: 8377 bytes, 227 lines) ---[39m
// CLI integration for Tree View feature
// This file adds tree view commands to the CLI

import { Command } from 'commander';
import * as path from 'path';
import chalk from 'chalk';
import { generateTree, formatTree, TreeViewConfig } from './TreeView';
import { FileContextBuilder } from '../FileContextBuilder';
import { PluginEnabledFileContextBuilder } from '../plugins/PluginEnabledFileContextBuilder';
import * as fs from 'fs-extra';

/**
 * Register tree view commands with the CLI
 * @param program Commander program instance
 */
export function registerTreeCommands(program: Command): void {
  // Add tree command
  const treeCommand = program
    .command('tree')
    .description('Show file tree of a directory');

  // Show tree
  treeCommand
    .command('show')
    .description('Show file tree of a directory')
    .option('-d, --dir <path>', 'Directory to show tree for (default: current directory)', process.cwd())
    .option('-H, --include-hidden', 'Include hidden files and directories')
    .option('-D, --max-depth <depth>', 'Maximum depth to traverse', parseInt)
    .option('-e, --exclude <patterns>', 'Patterns to exclude (comma-separated)')
    .option('-i, --include <patterns>', 'Patterns to include (comma-separated)')
    .option('-r, --regex', 'Use regex for pattern matching')
    .option('--no-dirs', 'Exclude directories from the output')
    .option('--no-files', 'Exclude files from the output')
    .option('--no-size', 'Don\'t show file sizes')
    .option('-m, --mod-time', 'Show file modification times')
    .option('-l, --list-only <patterns>', 'Patterns for files to list only (comma-separated)')
    .option('-o, --output <file>', 'Output file (default: stdout)')
    .option('-f, --format <format>', 'Output format (text, json)', 'text')
    .action(async (options) => {
      try {
        // Parse patterns
        const exclude = options.exclude ? options.exclude.split(',') : [];
        const include = options.include ? options.include.split(',') : [];
        const listOnlyPatterns = options.listOnly ? options.listOnly.split(',') : [];

        // Create tree config
        const treeConfig: TreeViewConfig = {
          rootDir: options.dir,
          includeHidden: options.includeHidden,
          maxDepth: options.maxDepth,
          exclude,
          include,
          useRegex: options.regex,
          includeDirs: options.dirs,
          includeFiles: options.files,
          includeSize: options.size,
          includeModTime: options.modTime,
          listOnlyPatterns
        };

        // Generate tree
        const tree = await generateTree(treeConfig);

        // Format output
        let output: string;
        if (options.format === 'json') {
          output = JSON.stringify(tree, null, 2);
        } else {
          output = formatTree(tree, {
            showSize: options.size,
            showModTime: options.modTime,
            showListOnly: true
          });
        }

        // Output result
        if (options.output) {
          await fs.writeFile(options.output, output);
          console.log(chalk.green(`Tree written to ${options.output}`));
        } else {
          console.log(output);
        }
      } catch (error) {
        console.error(chalk.red('Error showing tree:'), error instanceof Error ? error.message : String(error));
        process.exit(1);
      }
    });

  // Build context from tree
  treeCommand
    .command('build')
    .description('Build context from file tree')
    .option('-d, --dir <path>', 'Directory to show tree for (default: current directory)', process.cwd())
    .option('-H, --include-hidden', 'Include hidden files and directories')
    .option('-D, --max-depth <depth>', 'Maximum depth to traverse', parseInt)
    .option('-e, --exclude <patterns>', 'Patterns to exclude (comma-separated)')
    .option('-i, --include <patterns>', 'Patterns to include (comma-separated)')
    .option('-r, --regex', 'Use regex for pattern matching')
    .option('-l, --list-only <patterns>', 'Patterns for files to list only (comma-separated)')
    .option('-o, --output <file>', 'Output file (default: stdout)')
    .option('-f, --format <format>', 'Output format (console, json, markdown, html)', 'console')
    .option('--enable-plugins', 'Enable plugin system')
    .option('--security-scanners <ids>', 'Security scanner plugin IDs to use (comma-separated)')
    .option('--output-renderer <id>', 'Output renderer plugin ID to use')
    .option('--llm-reviewers <ids>', 'LLM reviewer plugin IDs to use (comma-separated)')
    .option('--generate-security-report', 'Generate security reports')
    .option('--generate-summaries', 'Generate summaries using LLM reviewers')
    .action(async (options) => {
      try {
        // Parse patterns
        const exclude = options.exclude ? options.exclude.split(',') : [];
        const include = options.include ? options.include.split(',') : [];
        const listOnlyPatterns = options.listOnly ? options.listOnly.split(',') : [];

        // Create tree config
        const treeConfig: TreeViewConfig = {
          rootDir: options.dir,
          includeHidden: options.includeHidden,
          maxDepth: options.maxDepth,
          exclude,
          include,
          useRegex: options.regex,
          includeDirs: true,
          includeFiles: true,
          includeSize: true,
          includeModTime: false,
          listOnlyPatterns
        };

        // Generate tree
        const tree = await generateTree(treeConfig);

        // Prepare file list
        const fileList: string[] = [];
        const listOnlyFiles: string[] = [];

        function traverseTree(node: any, basePath: string = '') {
          if (!node.isDirectory) {
            const fullPath = path.join(basePath, node.path);
            if (node.listOnly) {
              listOnlyFiles.push(fullPath);
            } else {
              fileList.push(fullPath);
            }
          }

          if (node.children) {
            for (const child of node.children) {
              traverseTree(child, basePath);
            }
          }
        }

        traverseTree(tree);

        // Create builder config
        const builderConfig = {
          includeFiles: fileList,
          listOnlyFiles: listOnlyFiles
        };

        // Create builder
        let builder;
        if (options.enablePlugins) {
          builder = new PluginEnabledFileContextBuilder(builderConfig);

          // Apply plugin options
          if (options.securityScanners) {
            (builder as any).pluginConfig.securityScanners = options.securityScanners.split(',');
          }

          if (options.outputRenderer) {
            (builder as any).pluginConfig.outputRenderer = options.outputRenderer;
          }

          if (options.llmReviewers) {
            (builder as any).pluginConfig.llmReviewers = options.llmReviewers.split(',');
          }

          if (options.generateSecurityReport) {
            (builder as any).pluginConfig.generateSecurityReports = true;
          }

          if (options.generateSummaries) {
            (builder as any).pluginConfig.generateSummaries = true;
          }
        } else {
          builder = new FileContextBuilder(builderConfig);
        }

        // Build context
        const result = await builder.build(options.format);

        // Output result
        if (options.output) {
          await fs.writeFile(options.output, result.output);
          console.log(chalk.green(`Context written to ${options.output}`));
        } else {
          console.log(result.output);
        }
      } catch (error) {
        console.error(chalk.red('Error building context from tree:'), error instanceof Error ? error.message : String(error));
        process.exit(1);
      }
    });

  // Add tree options to build command
  program.commands.forEach(cmd => {
    if (cmd.name() === 'build') {
      cmd
        .option('--show-tree', 'Show file tree before building context')
        .option('--list-only <patterns>', 'Patterns for files to list only (comma-separated)');
    }
  });
}

/**
 * Apply tree options from CLI to config
 * @param config Configuration object
 * @param options CLI options
 */
export function applyTreeOptions(config: any, options: any): void {
  if (options.listOnly) {
    config.listOnlyFiles = options.listOnly.split(',');
  }
}


[33m--- File: src/tree/TreeView.ts (Size: 12184 bytes, 472 lines) ---[39m
// Tree View Feature Implementation
// This file adds support for showing the full project tree

import * as fs from 'fs-extra';
import * as path from 'path';
import { FileCollectorConfig } from '../types';

/**
 * Configuration for tree view
 */
export interface TreeViewConfig {
  /** Root directory to start from */
  rootDir: string;

  /** Whether to include hidden files (default: false) */
  includeHidden?: boolean;

  /** Maximum depth to traverse (default: Infinity) */
  maxDepth?: number;

  /** File patterns to exclude */
  exclude?: string[];

  /** File patterns to include */
  include?: string[];

  /** Whether to use regex for pattern matching (default: false) */
  useRegex?: boolean;

  /** Whether to include directories in the result (default: true) */
  includeDirs?: boolean;

  /** Whether to include files in the result (default: true) */
  includeFiles?: boolean;

  /** Whether to include file sizes (default: true) */
  includeSize?: boolean;

  /** Whether to include file modification times (default: false) */
  includeModTime?: boolean;

  /** Files to mark as "list-only" (contents won't be included) */
  listOnlyPatterns?: string[];
}

/**
 * Tree node representing a file or directory
 */
export interface TreeNode {
  /** Path relative to root */
  path: string;

  /** Full path */
  fullPath: string;

  /** Whether this is a directory */
  isDirectory: boolean;

  /** Children (for directories) */
  children?: TreeNode[];

  /** File size in bytes (for files) */
  size?: number;

  /** Last modification time (for files) */
  modTime?: Date;

  /** Whether this file should be list-only (contents won't be included) */
  listOnly?: boolean;
}

/**
 * Generate a tree view of a directory
 * @param config Tree view configuration
 * @returns Tree structure
 */
export async function generateTree(config: TreeViewConfig): Promise<TreeNode> {
  const effectiveConfig = getEffectiveConfig(config);

  // Create root node
  const rootNode: TreeNode = {
    path: '',
    fullPath: effectiveConfig.rootDir,
    isDirectory: true,
    children: []
  };

  // Build tree recursively
  await buildTree(rootNode, effectiveConfig, 0);

  return rootNode;
}

/**
 * Build tree recursively
 * @param node Current node
 * @param config Tree view configuration
 * @param depth Current depth
 */
async function buildTree(
  node: TreeNode,
  config: TreeViewConfig,
  depth: number
): Promise<void> {
  // Check depth limit
  if (depth >= config.maxDepth!) {
    return;
  }

  try {
    // Read directory contents
    const entries = await fs.readdir(node.fullPath, { withFileTypes: true });

    // Process each entry
    for (const entry of entries) {
      const entryName = entry.name;
      const entryPath = path.join(node.path, entryName);
      const entryFullPath = path.join(node.fullPath, entryName);

      // Skip hidden files if not included
      if (!config.includeHidden && entryName.startsWith('.')) {
        continue;
      }

      // Check if entry should be excluded
      if (shouldExclude(entryPath, config)) {
        continue;
      }

      // Check if entry should be included
      if (config.include && config.include.length > 0 && !shouldInclude(entryPath, config)) {
        continue;
      }

      if (entry.isDirectory()) {
        // Skip directories if not included
        if (!config.includeDirs) {
          continue;
        }

        // Create directory node
        const dirNode: TreeNode = {
          path: entryPath,
          fullPath: entryFullPath,
          isDirectory: true,
          children: []
        };

        // Add to parent's children
        node.children!.push(dirNode);

        // Process directory recursively
        await buildTree(dirNode, config, depth + 1);
      } else {
        // Skip files if not included
        if (!config.includeFiles) {
          continue;
        }

        // Create file node
        const fileNode: TreeNode = {
          path: entryPath,
          fullPath: entryFullPath,
          isDirectory: false
        };

        // Add file size if requested
        if (config.includeSize) {
          try {
            const stats = await fs.stat(entryFullPath);
            fileNode.size = stats.size;

            // Add modification time if requested
            if (config.includeModTime) {
              fileNode.modTime = stats.mtime;
            }
          } catch (error) {
            console.warn(`Error getting stats for ${entryFullPath}:`, error);
          }
        }

        // Check if file should be list-only
        if (isListOnly(entryPath, config)) {
          fileNode.listOnly = true;
        }

        // Add to parent's children
        node.children!.push(fileNode);
      }
    }

    // Sort children: directories first, then files, both alphabetically
    node.children!.sort((a, b) => {
      if (a.isDirectory && !b.isDirectory) {
        return -1;
      }
      if (!a.isDirectory && b.isDirectory) {
        return 1;
      }
      return a.path.localeCompare(b.path);
    });
  } catch (error) {
    console.error(`Error reading directory ${node.fullPath}:`, error);
  }
}

/**
 * Check if a path should be excluded
 * @param relativePath Path relative to root
 * @param config Tree view configuration
 * @returns Whether the path should be excluded
 */
function shouldExclude(relativePath: string, config: TreeViewConfig): boolean {
  if (!config.exclude || config.exclude.length === 0) {
    return false;
  }

  for (const pattern of config.exclude) {
    if (config.useRegex) {
      try {
        const regex = new RegExp(pattern);
        if (regex.test(relativePath)) {
          return true;
        }
      } catch (error) {
        console.warn(`Invalid regex pattern: ${pattern}`, error);
      }
    } else {
      // Use glob-like pattern matching
      if (matchGlobPattern(relativePath, pattern)) {
        return true;
      }
    }
  }

  return false;
}

/**
 * Check if a path should be included
 * @param relativePath Path relative to root
 * @param config Tree view configuration
 * @returns Whether the path should be included
 */
function shouldInclude(relativePath: string, config: TreeViewConfig): boolean {
  if (!config.include || config.include.length === 0) {
    return true;
  }

  for (const pattern of config.include) {
    if (config.useRegex) {
      try {
        const regex = new RegExp(pattern);
        if (regex.test(relativePath)) {
          return true;
        }
      } catch (error) {
        console.warn(`Invalid regex pattern: ${pattern}`, error);
      }
    } else {
      // Use glob-like pattern matching
      if (matchGlobPattern(relativePath, pattern)) {
        return true;
      }
    }
  }

  return false;
}

/**
 * Check if a file should be list-only
 * @param relativePath Path relative to root
 * @param config Tree view configuration
 * @returns Whether the file should be list-only
 */
function isListOnly(relativePath: string, config: TreeViewConfig): boolean {
  if (!config.listOnlyPatterns || config.listOnlyPatterns.length === 0) {
    return false;
  }

  for (const pattern of config.listOnlyPatterns) {
    if (config.useRegex) {
      try {
        const regex = new RegExp(pattern);
        if (regex.test(relativePath)) {
          return true;
        }
      } catch (error) {
        console.warn(`Invalid regex pattern: ${pattern}`, error);
      }
    } else {
      // Use glob-like pattern matching
      if (matchGlobPattern(relativePath, pattern)) {
        return true;
      }
    }
  }

  return false;
}

/**
 * Match a path against a glob pattern
 * @param path Path to match
 * @param pattern Glob pattern
 * @returns Whether the path matches the pattern
 */
function matchGlobPattern(path: string, pattern: string): boolean {
  // Convert glob pattern to regex
  const regexPattern = pattern
    .replace(/\./g, '\\.')
    .replace(/\*\*/g, '.*')
    .replace(/\*/g, '[^/]*')
    .replace(/\?/g, '.');

  const regex = new RegExp(`^${regexPattern}$`);
  return regex.test(path);
}

/**
 * Get effective configuration with defaults
 * @param config User-provided configuration
 * @returns Effective configuration with defaults applied
 */
function getEffectiveConfig(config: TreeViewConfig): TreeViewConfig {
  return {
    rootDir: config.rootDir,
    includeHidden: config.includeHidden || false,
    maxDepth: config.maxDepth || Infinity,
    exclude: config.exclude || [],
    include: config.include || [],
    useRegex: config.useRegex || false,
    includeDirs: config.includeDirs !== false,
    includeFiles: config.includeFiles !== false,
    includeSize: config.includeSize !== false,
    includeModTime: config.includeModTime || false,
    listOnlyPatterns: config.listOnlyPatterns || []
  };
}

/**
 * Convert tree to a flat list of files
 * @param tree Tree structure
 * @returns Flat list of file paths
 */
export function treeToFileList(tree: TreeNode): string[] {
  const result: string[] = [];

  function traverse(node: TreeNode) {
    if (!node.isDirectory) {
      result.push(node.path);
    }

    if (node.children) {
      for (const child of node.children) {
        traverse(child);
      }
    }
  }

  traverse(tree);
  return result;
}

/**
 * Format tree as a string
 * @param tree Tree structure
 * @param options Formatting options
 * @returns Formatted tree string
 */
export function formatTree(
  tree: TreeNode,
  options: {
    showSize?: boolean;
    showModTime?: boolean;
    showListOnly?: boolean;
  } = {}
): string {
  const lines: string[] = [];

  function traverse(node: TreeNode, prefix: string = '', isLast: boolean = true) {
    // Skip root node
    if (node.path !== '') {
      const nodeName = path.basename(node.path);
      const connector = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
      let line = `${prefix}${connector}${nodeName}`;

      // Add size if requested and available
      if (options.showSize && node.size !== undefined) {
        line += ` (${formatSize(node.size)})`;
      }

      // Add modification time if requested and available
      if (options.showModTime && node.modTime) {
        line += ` [${node.modTime.toISOString()}]`;
      }

      // Add list-only indicator if requested and applicable
      if (options.showListOnly && node.listOnly) {
        line += ' [list-only]';
      }

      lines.push(line);
    }

    if (node.children) {
      const childPrefix = node.path === '' ? '' : `${prefix}${isLast ? '    ' : 'â”‚   '}`;

      for (let i = 0; i < node.children.length; i++) {
        const isLastChild = i === node.children.length - 1;
        traverse(node.children[i], childPrefix, isLastChild);
      }
    }
  }

  traverse(tree);
  return lines.join('\n');
}

/**
 * Format file size in human-readable format
 * @param size Size in bytes
 * @returns Formatted size
 */
function formatSize(size: number): string {
  if (size < 1024) {
    return `${size} B`;
  } else if (size < 1024 * 1024) {
    return `${(size / 1024).toFixed(1)} KB`;
  } else if (size < 1024 * 1024 * 1024) {
    return `${(size / (1024 * 1024)).toFixed(1)} MB`;
  } else {
    return `${(size / (1024 * 1024 * 1024)).toFixed(1)} GB`;
  }
}

/**
 * Integrate tree view with FileCollectorConfig
 * @param treeConfig Tree view configuration
 * @param collectorConfig File collector configuration
 * @returns Updated file collector configuration
 */
export async function integrateTreeWithCollector(
  treeConfig: TreeViewConfig,
  collectorConfig: FileCollectorConfig = {}
): Promise<FileCollectorConfig> {
  // Generate tree
  const tree = await generateTree(treeConfig);

  // Convert tree to file list
  const fileList = treeToFileList(tree);

  // Create list-only patterns
  const listOnlyPatterns = treeConfig.listOnlyPatterns || [];

  // Update collector config
  const updatedConfig: FileCollectorConfig = {
    ...collectorConfig,
    includeFiles: [
      ...(collectorConfig.includeFiles || []),
      ...fileList.filter(file => !isListOnly(file, treeConfig))
    ],
    listOnlyFiles: [
      ...(collectorConfig.listOnlyFiles || []),
      ...fileList.filter(file => isListOnly(file, treeConfig))
    ]
  };

  return updatedConfig;
}


[33m--- File: src/cli/studio/index.ts (Size: 10240 bytes, 334 lines) ---[39m
#!/usr/bin/env node

import express from 'express';
import path from 'path';
import open from 'open';
import { dirname } from 'path';
import fs from 'fs';
import bodyParser from 'body-parser';
import {
  FileContextBuilder,
  FileCollectorConfig,
  ConsoleRenderer,
  JsonRenderer,
  WhitelistBlacklist,
  FileContentSearch,
  FileSearchOptions,
  RegexPatternMatcher
} from '../../index';

// Get current directory
// In CommonJS environment, __dirname is already available
// For TypeScript compilation, we'll declare it if not available
const currentFilename = 'index.js';
const currentDirname = __dirname || dirname(currentFilename);

const app = express();
const PORT = process.env.CONTEXTR_STUDIO_PORT ? parseInt(process.env.CONTEXTR_STUDIO_PORT, 10) : 3000;
const HOST = process.env.CONTEXTR_STUDIO_HOST || 'localhost';
const OPEN_BROWSER = process.env.CONTEXTR_STUDIO_OPEN_BROWSER === 'true';

// Middleware
app.use(bodyParser.json());
app.use((express as any).static(path.join(currentDirname, 'public')));

// API Routes
app.get('/api/files', async (req, res) => {
  try {
    const dirPath = req.query.path || '.';
    const files = fs.readdirSync(dirPath, { withFileTypes: true });

    const fileList = files.map(file => ({
      name: file.name,
      isDirectory: file.isDirectory(),
      path: path.join(dirPath.toString(), file.name),
      extension: file.isDirectory() ? null : path.extname(file.name).substring(1)
    }));

    res.json(fileList);
  } catch (error) {
    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
  }
});

app.post('/api/context/build', async (req, res) => {
  try {
    const config = req.body.config;

    if (!config) {
      return res.status(400).json({ error: 'Configuration is required' });
    }

    const builder = new FileContextBuilder(config);
    const context = await builder.build();

    // Apply additional filters if provided
    let filteredFiles = context.files;

    // Filter by extensions if specified
    if (req.body.extensions && req.body.extensions.length > 0) {
      filteredFiles = filteredFiles.filter(file => {
        const ext = path.extname(file.filePath).substring(1);
        return req.body.extensions.includes(ext);
      });
    }

    // Filter by content search if specified
    if (req.body.searchInFiles) {
      const { pattern, isRegex } = req.body.searchInFiles;
      if (pattern) {
        filteredFiles = filteredFiles.filter(file => {
          if (isRegex) {
            return RegexPatternMatcher.test(file.content, pattern, 'gm');
          } else {
            return file.content.includes(pattern);
          }
        });
      }
    }

    // Update context with filtered files
    context.files = filteredFiles;

    if (req.body.format === 'json') {
      const jsonRenderer = new JsonRenderer();
      const jsonOutput = jsonRenderer.render(context);
      res.json({
        context: jsonOutput,
        totalFiles: context.files.length,
        totalSize: context.files.reduce((sum, file) => sum + file.content.length, 0)
      });
    } else {
      const consoleRenderer = new ConsoleRenderer();
      const output = consoleRenderer.render(context);
      res.json({
        output,
        totalFiles: context.files.length,
        totalSize: context.files.reduce((sum, file) => sum + file.content.length, 0)
      });
    }
  } catch (error) {
    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
  }
});

app.post('/api/search', async (req, res) => {
  try {
    const { config, searchOptions } = req.body;

    if (!config || !searchOptions) {
      return res.status(400).json({ error: 'Configuration and search options are required' });
    }

    const builder = new FileContextBuilder(config);
    const context = await builder.build();

    // Apply extension filtering if specified
    let filesToSearch = context.files;
    if (req.body.extensions && req.body.extensions.length > 0) {
      filesToSearch = filesToSearch.filter(file => {
        const ext = path.extname(file.filePath).substring(1);
        return req.body.extensions.includes(ext);
      });
    }

    const results = FileContentSearch.searchInFiles(filesToSearch, searchOptions);

    // Add context lines if requested
    let resultsWithContext = results;
    if (searchOptions.contextLines && searchOptions.contextLines > 0) {
      resultsWithContext = results.map(result =>
        FileContentSearch.addContextLines(result, searchOptions.contextLines)
      );
    }

    res.json({
      totalFiles: filesToSearch.length,
      matchedFiles: results.length,
      totalMatches: results.reduce((sum, result) => sum + result.matchCount, 0),
      results: resultsWithContext
    });
  } catch (error) {
    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
  }
});

app.post('/api/config/save', (req, res) => {
  try {
    const { name, config } = req.body;

    if (!name || !config) {
      return res.status(400).json({ error: 'Name and configuration are required' });
    }

    // Use home directory for global configs or current directory for project configs
    const configDir = req.body.global
      ? path.join(process.env.HOME || process.env.USERPROFILE || '.', '.contextr')
      : path.join(process.cwd(), '.contextr');

    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }

    const configPath = path.join(configDir, `${name}.json`);
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

    res.json({ success: true, path: configPath });
  } catch (error) {
    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
  }
});

app.get('/api/config/list', (req, res) => {
  try {
    // Check both global and project config directories
    const globalConfigDir = path.join(process.env.HOME || process.env.USERPROFILE || '.', '.contextr');
    const projectConfigDir = path.join(process.cwd(), '.contextr');

    const configs: Array<{name: string, path: string, isGlobal: boolean}> = [];

    // Get global configs
    if (fs.existsSync(globalConfigDir)) {
      const globalFiles = fs.readdirSync(globalConfigDir);
      globalFiles
        .filter(file => file.endsWith('.json'))
        .forEach(file => {
          configs.push({
            name: file.replace('.json', ''),
            path: path.join(globalConfigDir, file),
            isGlobal: true
          });
        });
    }

    // Get project configs
    if (fs.existsSync(projectConfigDir)) {
      const projectFiles = fs.readdirSync(projectConfigDir);
      projectFiles
        .filter(file => file.endsWith('.json'))
        .forEach(file => {
          configs.push({
            name: file.replace('.json', ''),
            path: path.join(projectConfigDir, file),
            isGlobal: false
          });
        });
    }

    res.json({ configs });
  } catch (error) {
    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
  }
});

app.get('/api/config/load', (req, res) => {
  try {
    const name = req.query.name;
    const isGlobal = req.query.global === 'true';

    if (!name) {
      return res.status(400).json({ error: 'Config name is required' });
    }

    // Determine config path based on global flag
    const configDir = isGlobal
      ? path.join(process.env.HOME || process.env.USERPROFILE || '.', '.contextr')
      : path.join(process.cwd(), '.contextr');

    const configPath = path.join(configDir, `${name}.json`);

    if (!fs.existsSync(configPath)) {
      return res.status(404).json({ error: `Config '${name}' not found` });
    }

    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    res.json({ config });
  } catch (error) {
    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
  }
});

app.delete('/api/config/delete', (req, res) => {
  try {
    const name = req.query.name;
    const isGlobal = req.query.global === 'true';

    if (!name) {
      return res.status(400).json({ error: 'Config name is required' });
    }

    // Determine config path based on global flag
    const configDir = isGlobal
      ? path.join(process.env.HOME || process.env.USERPROFILE || '.', '.contextr')
      : path.join(process.cwd(), '.contextr');

    const configPath = path.join(configDir, `${name}.json`);

    if (!fs.existsSync(configPath)) {
      return res.status(404).json({ error: `Config '${name}' not found` });
    }

    fs.unlinkSync(configPath);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
  }
});

app.get('/api/file/content', (req, res) => {
  try {
    const filePath = req.query.path;

    if (!filePath) {
      return res.status(400).json({ error: 'File path is required' });
    }

    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: `File not found: ${filePath}` });
    }

    const stats = fs.statSync(filePath);

    if (stats.isDirectory()) {
      return res.status(400).json({ error: `Path is a directory: ${filePath}` });
    }

    // Check file size to avoid loading very large files
    const MAX_SIZE = 5 * 1024 * 1024; // 5MB
    if (stats.size > MAX_SIZE) {
      return res.status(413).json({
        error: `File too large (${(stats.size / 1024 / 1024).toFixed(2)}MB). Maximum size is 5MB.`
      });
    }

    const content = fs.readFileSync(filePath, 'utf8');
    res.json({ content });
  } catch (error) {
    res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
  }
});

// Serve the main HTML file
app.get('/', (req, res) => {
  res.sendFile(path.join(currentDirname, 'public', 'index.html'));
});

// Start the server
const server = app.listen(PORT, HOST, () => {
  console.log(`ContextR Studio running at http://${HOST}:${PORT}`);
  if (OPEN_BROWSER) {
    open(`http://${HOST}:${PORT}`);
  }
});

// Handle graceful shutdown
process.on('SIGINT', () => {
  console.log('Shutting down ContextR Studio...');
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});

export default app;


[33m--- File: src/plugins/output-renderers/HTMLRenderer.ts (Size: 18315 bytes, 730 lines) ---[39m
// HTML Output Renderer Plugin
// This plugin renders context files to HTML format with syntax highlighting

import * as path from 'path';
import {
  Plugin,
  PluginType,
  OutputRendererPlugin,
  SecurityIssueSeverity
} from '../PluginManager';
import { CollectedFile } from '../../types';

/**
 * Configuration for HTML renderer
 */
interface HTMLRendererConfig {
  /** Include file metadata (default: true) */
  includeMetadata?: boolean;

  /** Include table of contents (default: true) */
  includeTableOfContents?: boolean;

  /** Include security warnings (default: true) */
  includeSecurityWarnings?: boolean;

  /** Include line numbers (default: true) */
  includeLineNumbers?: boolean;

  /** Custom title for the document (default: "Project Context") */
  title?: string;

  /** Group files by directory (default: true) */
  groupByDirectory?: boolean;

  /** Include CSS in the HTML (default: true) */
  includeCSS?: boolean;

  /** Custom CSS to add to the HTML */
  customCSS?: string;

  /** Include collapsible sections (default: true) */
  collapsibleSections?: boolean;
}

/**
 * HTML Output Renderer Plugin
 * Renders context files to HTML format with syntax highlighting
 */
export class HTMLRenderer implements OutputRendererPlugin {
  id = 'html-renderer';
  name = 'HTML Renderer';
  type: PluginType.OUTPUT_RENDERER = PluginType.OUTPUT_RENDERER;
  version = '1.0.0';
  description = 'Renders context files to HTML format with syntax highlighting and interactive features';

  /**
   * Initialize the plugin
   */
  async initialize(): Promise<void> {
    // Nothing to initialize
  }

  /**
   * Get the format name for this renderer
   */
  getFormatName(): string {
    return 'html';
  }

  /**
   * Render files to HTML format
   * @param files Files to render
   * @param config Configuration for the renderer
   * @returns Rendered HTML
   */
  async render(files: CollectedFile[], config?: HTMLRendererConfig): Promise<string> {
    const effectiveConfig = this.getEffectiveConfig(config);

    // Start building HTML
    let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${this.escapeHtml(effectiveConfig.title || 'Code Context')}</title>
  ${this.getStylesTag(effectiveConfig)}
</head>
<body>
  <div class="container">
    <header>
      <h1>${this.escapeHtml(effectiveConfig.title || 'Code Context')}</h1>
      <div class="summary">
        <p>This context contains ${files.length} files.</p>
        <p>Total size: ${this.formatSize(files.reduce((sum, file) => sum + (file.meta?.size || 0), 0))}</p>
      </div>
    </header>`;

    // Add table of contents if enabled
    if (effectiveConfig.includeTableOfContents) {
      html += `
    <nav class="toc">
      <h2>Table of Contents</h2>
      <ul>`;

      if (effectiveConfig.groupByDirectory) {
        // Group files by directory
        const filesByDirectory = this.groupFilesByDirectory(files);

        for (const [directory, directoryFiles] of Object.entries(filesByDirectory)) {
          if (directory === '') {
            // Root directory
            for (const file of directoryFiles) {
              const fileName = path.basename(file.filePath);
              const anchor = this.createAnchor(file.filePath);
              html += `
        <li><a href="#${anchor}">${this.escapeHtml(fileName)}</a></li>`;
            }
          } else {
            // Subdirectory
            html += `
        <li class="directory">
          <span>${this.escapeHtml(directory)}/</span>
          <ul>`;

            for (const file of directoryFiles) {
              const fileName = path.basename(file.filePath);
              const anchor = this.createAnchor(file.filePath);
              html += `
            <li><a href="#${anchor}">${this.escapeHtml(fileName)}</a></li>`;
            }

            html += `
          </ul>
        </li>`;
          }
        }
      } else {
        // Flat list of files
        for (const file of files) {
          const anchor = this.createAnchor(file.filePath);
          html += `
        <li><a href="#${anchor}">${this.escapeHtml(file.filePath)}</a></li>`;
        }
      }

      html += `
      </ul>
    </nav>`;
    }

    // Add security warnings if enabled and present
    if (effectiveConfig.includeSecurityWarnings) {
      const filesWithIssues = files.filter(file =>
        file.meta?.securityIssues && file.meta.securityIssues.length > 0
      );

      if (filesWithIssues.length > 0) {
        html += `
    <section class="security-warnings">
      <h2>Security Warnings</h2>
      <p>The following files have security warnings:</p>`;

        for (const file of filesWithIssues) {
          const issues = file.meta?.securityIssues || [];
          html += `
      <div class="file-warnings">
        <h3>${this.escapeHtml(file.filePath)}</h3>
        <ul>`;

          for (const issue of issues) {
            const severity = issue.severity || 'warning';
            html += `
          <li class="severity-${severity.toLowerCase()}">
            <strong>${severity.toUpperCase()}:</strong> ${this.escapeHtml(issue.message)}`;

            if (issue.details) {
              html += `
            <div class="details">${this.escapeHtml(issue.details)}</div>`;
            }

            html += `
          </li>`;
          }

          html += `
        </ul>
      </div>`;
        }

        html += `
    </section>`;
      }
    }

    // Add file contents
    html += `
    <section class="files">
      <h2>Files</h2>`;

    if (effectiveConfig.groupByDirectory) {
      // Group files by directory
      const filesByDirectory = this.groupFilesByDirectory(files);

      for (const [directory, directoryFiles] of Object.entries(filesByDirectory)) {
        if (directory !== '') {
          html += `
      <div class="directory-group">
        <h3 class="directory-heading">${this.escapeHtml(directory)}/</h3>`;
        }

        for (const file of directoryFiles) {
          html += this.renderFileHtml(file, effectiveConfig);
        }

        if (directory !== '') {
          html += `
      </div>`;
        }
      }
    } else {
      // Render files in order
      for (const file of files) {
        html += this.renderFileHtml(file, effectiveConfig);
      }
    }

    html += `
    </section>
  </div>`;

    // Add JavaScript for interactive features
    if (effectiveConfig.collapsibleSections) {
      html += `
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Make file sections collapsible
      document.querySelectorAll('.file-heading').forEach(heading => {
        heading.addEventListener('click', function() {
          this.parentElement.classList.toggle('collapsed');
        });
      });

      // Make directory sections collapsible
      document.querySelectorAll('.directory-heading').forEach(heading => {
        heading.addEventListener('click', function() {
          this.parentElement.classList.toggle('collapsed');
        });
      });
    });
  </script>`;
    }

    html += `
</body>
</html>`;

    return html;
  }

  /**
   * Render a single file to HTML
   * @param file File to render
   * @param config Renderer configuration
   * @returns HTML for the file
   */
  private renderFileHtml(
    file: CollectedFile,
    config: HTMLRendererConfig
  ): string {
    const anchor = this.createAnchor(file.filePath);
    let html = `
      <div class="file" id="${anchor}">
        <h3 class="file-heading">${this.escapeHtml(file.filePath)}</h3>
        <div class="file-content">`;

    // Add metadata if enabled
    if (config.includeMetadata && file.meta) {
      html += `
          <div class="metadata">`;

      if (file.meta.size !== undefined) {
        html += `
            <div class="meta-item">Size: ${this.formatSize(file.meta.size)}</div>`;
      }

      if (file.meta.lastModified) {
        html += `
            <div class="meta-item">Last Modified: ${new Date(file.meta.lastModified).toISOString()}</div>`;
      }

      if (file.meta.type) {
        html += `
            <div class="meta-item">Type: ${this.escapeHtml(file.meta.type)}</div>`;
      }

      html += `
          </div>`;
    }

    // Add security warnings if enabled and present
    if (config.includeSecurityWarnings && file.meta?.securityIssues && file.meta.securityIssues.length > 0) {
      html += `
          <div class="file-warnings">
            <ul>`;

      for (const issue of file.meta.securityIssues) {
        const severity = issue.severity || 'warning';
        html += `
              <li class="severity-${severity.toLowerCase()}">
                <strong>${severity.toUpperCase()}:</strong> ${this.escapeHtml(issue.message)}
              </li>`;
      }

      html += `
            </ul>
          </div>`;
    }

    // Add file content with syntax highlighting based on extension
    const extension = path.extname(file.filePath).substring(1);
    const language = this.getLanguageForExtension(extension);

    html += `
          <pre class="code${language ? ` language-${language}` : ''}">`;

    if (config.includeLineNumbers) {
      // Add content with line numbers
      const lines = file.content.split('\n');

      for (let i = 0; i < lines.length; i++) {
        const lineNumber = i + 1;
        const lineContent = this.escapeHtml(lines[i]);
        html += `<div class="line"><span class="line-number">${lineNumber}</span><span class="line-content">${lineContent}</span></div>`;
      }
    } else {
      // Add content without line numbers
      html += this.escapeHtml(file.content);
    }

    html += `</pre>
        </div>
      </div>`;

    return html;
  }

  /**
   * Get CSS styles tag
   * @param config Renderer configuration
   * @returns HTML style tag with CSS
   */
  private getStylesTag(config: HTMLRendererConfig): string {
    if (!config.includeCSS) {
      return '';
    }

    const defaultCSS = `
    :root {
      --primary-color: #4a6fa5;
      --secondary-color: #6c757d;
      --background-color: #ffffff;
      --code-background: #f8f9fa;
      --border-color: #dee2e6;
      --text-color: #212529;
      --link-color: #0366d6;
      --warning-color: #ffc107;
      --error-color: #dc3545;
      --critical-color: #721c24;
      --info-color: #17a2b8;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.5;
      color: var(--text-color);
      background-color: var(--background-color);
      margin: 0;
      padding: 0;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    header {
      margin-bottom: 2rem;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 1rem;
    }

    h1, h2, h3, h4 {
      margin-top: 0;
      color: var(--primary-color);
    }

    a {
      color: var(--link-color);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .toc {
      background-color: var(--code-background);
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 2rem;
    }

    .toc ul {
      list-style-type: none;
      padding-left: 1rem;
    }

    .toc li {
      margin-bottom: 0.5rem;
    }

    .directory > span {
      font-weight: bold;
      color: var(--secondary-color);
    }

    .file {
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      overflow: hidden;
    }

    .file-heading {
      background-color: var(--primary-color);
      color: white;
      padding: 0.75rem 1rem;
      margin: 0;
      cursor: pointer;
      position: relative;
    }

    .file-heading:after {
      content: "â–¼";
      position: absolute;
      right: 1rem;
      transition: transform 0.2s;
    }

    .file.collapsed .file-heading:after {
      transform: rotate(-90deg);
    }

    .file.collapsed .file-content {
      display: none;
    }

    .file-content {
      padding: 1rem;
    }

    .metadata {
      background-color: var(--code-background);
      padding: 0.5rem 1rem;
      margin-bottom: 1rem;
      border-radius: 4px;
      font-size: 0.9rem;
      color: var(--secondary-color);
    }

    .file-warnings {
      margin-bottom: 1rem;
    }

    .file-warnings ul {
      list-style-type: none;
      padding-left: 0;
      margin: 0;
    }

    .file-warnings li {
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      border-radius: 4px;
    }

    .severity-info {
      background-color: rgba(23, 162, 184, 0.1);
      border-left: 4px solid var(--info-color);
    }

    .severity-warning {
      background-color: rgba(255, 193, 7, 0.1);
      border-left: 4px solid var(--warning-color);
    }

    .severity-error {
      background-color: rgba(220, 53, 69, 0.1);
      border-left: 4px solid var(--error-color);
    }

    .severity-critical {
      background-color: rgba(114, 28, 36, 0.1);
      border-left: 4px solid var(--critical-color);
    }

    pre.code {
      background-color: var(--code-background);
      border-radius: 4px;
      padding: 1rem;
      overflow-x: auto;
      margin: 0;
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
      font-size: 0.9rem;
    }

    .line {
      display: flex;
      white-space: pre;
    }

    .line-number {
      color: var(--secondary-color);
      text-align: right;
      padding-right: 1rem;
      user-select: none;
      min-width: 3rem;
      border-right: 1px solid var(--border-color);
      margin-right: 1rem;
    }

    .line-content {
      flex: 1;
    }

    .directory-group {
      margin-bottom: 2rem;
    }

    .directory-heading {
      color: var(--secondary-color);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5rem;
      margin-top: 2rem;
      cursor: pointer;
    }

    .directory-group.collapsed .file {
      display: none;
    }

    .security-warnings {
      margin-bottom: 2rem;
      padding: 1rem;
      background-color: rgba(255, 193, 7, 0.1);
      border-radius: 4px;
    }

    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }
    }`;

    return `<style>
${defaultCSS}
${config.customCSS || ''}
</style>`;
  }

  /**
   * Group files by directory
   * @param files Files to group
   * @returns Files grouped by directory
   */
  private groupFilesByDirectory(files: CollectedFile[]): Record<string, CollectedFile[]> {
    const result: Record<string, CollectedFile[]> = {};

    for (const file of files) {
      const directory = path.dirname(file.filePath);

      if (!result[directory]) {
        result[directory] = [];
      }

      result[directory].push(file);
    }

    return result;
  }

  /**
   * Create an anchor ID from a file path
   * @param filePath File path
   * @returns Anchor ID
   */
  private createAnchor(filePath: string): string {
    return filePath
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .toLowerCase();
  }

  /**
   * Format file size in human-readable format
   * @param size Size in bytes
   * @returns Formatted size
   */
  private formatSize(size: number): string {
    if (size < 1024) {
      return `${size} bytes`;
    } else if (size < 1024 * 1024) {
      return `${(size / 1024).toFixed(2)} KB`;
    } else if (size < 1024 * 1024 * 1024) {
      return `${(size / (1024 * 1024)).toFixed(2)} MB`;
    } else {
      return `${(size / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }
  }

  /**
   * Get language identifier for syntax highlighting based on file extension
   * @param extension File extension
   * @returns Language identifier
   */
  private getLanguageForExtension(extension: string): string {
    const extensionMap: Record<string, string> = {
      // Programming languages
      'js': 'javascript',
      'jsx': 'jsx',
      'ts': 'typescript',
      'tsx': 'tsx',
      'py': 'python',
      'rb': 'ruby',
      'java': 'java',
      'c': 'c',
      'cpp': 'cpp',
      'cs': 'csharp',
      'go': 'go',
      'rs': 'rust',
      'php': 'php',
      'swift': 'swift',
      'kt': 'kotlin',
      'scala': 'scala',

      // Web technologies
      'html': 'html',
      'htm': 'html',
      'css': 'css',
      'scss': 'scss',
      'sass': 'sass',
      'less': 'less',
      'json': 'json',
      'xml': 'xml',
      'svg': 'svg',

      // Configuration files
      'yml': 'yaml',
      'yaml': 'yaml',
      'toml': 'toml',
      'ini': 'ini',
      'env': 'dotenv',

      // Shell scripts
      'sh': 'bash',
      'bash': 'bash',
      'zsh': 'bash',
      'bat': 'batch',
      'ps1': 'powershell',

      // Documentation
      'md': 'markdown',
      'markdown': 'markdown',
      'txt': 'text',

      // Other
      'sql': 'sql',
      'graphql': 'graphql',
      'dockerfile': 'dockerfile',
      'gitignore': 'gitignore'
    };

    return extensionMap[extension.toLowerCase()] || '';
  }

  /**
   * Escape HTML special characters
   * @param text Text to escape
   * @returns Escaped text
   */
  private escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  /**
   * Get effective configuration with defaults
   * @param config User-provided configuration
   * @returns Effective configuration with defaults applied
   */
  private getEffectiveConfig(config?: HTMLRendererConfig): HTMLRendererConfig {
    return {
      includeMetadata: config?.includeMetadata !== false,
      includeTableOfContents: config?.includeTableOfContents !== false,
      includeSecurityWarnings: config?.includeSecurityWarnings !== false,
      includeLineNumbers: config?.includeLineNumbers !== false,
      title: config?.title || 'Project Context',
      groupByDirectory: config?.groupByDirectory !== false,
      includeCSS: config?.includeCSS !== false,
      customCSS: config?.customCSS || '',
      collapsibleSections: config?.collapsibleSections !== false
    };
  }

  /**
   * Clean up resources
   */
  async cleanup(): Promise<void> {
    // Nothing to clean up
  }
}

// Export plugin instance
export default new HTMLRenderer();


[33m--- File: src/plugins/output-renderers/MarkdownRenderer.ts (Size: 11125 bytes, 399 lines) ---[39m
// Markdown Output Renderer Plugin
// This plugin renders context files to Markdown format

import * as path from 'path';
import {
  Plugin,
  PluginType,
  OutputRendererPlugin
} from '../PluginManager';
import { CollectedFile } from '../../types';

/**
 * Configuration for Markdown renderer
 */
interface MarkdownRendererConfig {
  /** Include file metadata (default: true) */
  includeMetadata?: boolean;

  /** Include table of contents (default: true) */
  includeTableOfContents?: boolean;

  /** Include security warnings (default: true) */
  includeSecurityWarnings?: boolean;

  /** Include line numbers (default: false) */
  includeLineNumbers?: boolean;

  /** Custom title for the document (default: "Project Context") */
  title?: string;

  /** Group files by directory (default: true) */
  groupByDirectory?: boolean;
}

/**
 * Markdown Output Renderer Plugin
 * Renders context files to Markdown format
 */
export class MarkdownRenderer implements OutputRendererPlugin {
  id = 'markdown-renderer';
  name = 'Markdown Renderer';
  type: PluginType.OUTPUT_RENDERER = PluginType.OUTPUT_RENDERER;
  version = '1.0.0';
  description = 'Renders context files to Markdown format with syntax highlighting';

  /**
   * Initialize the plugin
   */
  async initialize(): Promise<void> {
    // Nothing to initialize
  }

  /**
   * Get the format name for this renderer
   */
  getFormatName(): string {
    return 'markdown';
  }

  /**
   * Render files to Markdown format
   * @param files Files to render
   * @param config Configuration for the renderer
   * @returns Rendered Markdown
   */
  async render(files: CollectedFile[], config?: MarkdownRendererConfig): Promise<string> {
    const effectiveConfig = this.getEffectiveConfig(config);
    const output: string[] = [];

    // Add title
    output.push(`# ${effectiveConfig.title}`);
    output.push('');

    // Add summary
    output.push(`## Summary`);
    output.push('');
    output.push(`This context contains ${files.length} files.`);

    // Add file size information
    const totalSize = files.reduce((sum, file) => sum + (file.meta?.size || 0), 0);
    output.push(`Total size: ${this.formatSize(totalSize)}`);
    output.push('');

    // Add table of contents if enabled
    if (effectiveConfig.includeTableOfContents) {
      output.push(`## Table of Contents`);
      output.push('');

      if (effectiveConfig.groupByDirectory) {
        // Group files by directory
        const filesByDirectory = this.groupFilesByDirectory(files);

        for (const [directory, directoryFiles] of Object.entries(filesByDirectory)) {
          if (directory === '') {
            // Root directory
            for (const file of directoryFiles) {
              const fileName = path.basename(file.filePath);
              const anchor = this.createAnchor(file.filePath);
              output.push(`- [${fileName}](#${anchor})`);
            }
          } else {
            // Subdirectory
            output.push(`- ${directory}/`);
            for (const file of directoryFiles) {
              const fileName = path.basename(file.filePath);
              const anchor = this.createAnchor(file.filePath);
              output.push(`  - [${fileName}](#${anchor})`);
            }
          }
        }
      } else {
        // Flat list of files
        for (const file of files) {
          const anchor = this.createAnchor(file.filePath);
          output.push(`- [${file.filePath}](#${anchor})`);
        }
      }

      output.push('');
    }

    // Add security warnings if enabled and present
    if (effectiveConfig.includeSecurityWarnings) {
      const filesWithIssues = files.filter(file =>
        file.meta?.securityIssues && file.meta.securityIssues.length > 0
      );

      if (filesWithIssues.length > 0) {
        output.push(`## Security Warnings`);
        output.push('');
        output.push('The following files have security warnings:');
        output.push('');

        for (const file of filesWithIssues) {
          const issues = file.meta?.securityIssues || [];
          output.push(`### ${file.filePath}`);
          output.push('');

          for (const issue of issues) {
            const severity = issue.severity || 'warning';
            output.push(`- **${severity.toUpperCase()}**: ${issue.message}`);
            if (issue.details) {
              output.push(`  - ${issue.details}`);
            }
          }

          output.push('');
        }
      }
    }

    // Add file contents
    output.push(`## Files`);
    output.push('');

    if (effectiveConfig.groupByDirectory) {
      // Group files by directory
      const filesByDirectory = this.groupFilesByDirectory(files);

      for (const [directory, directoryFiles] of Object.entries(filesByDirectory)) {
        if (directory !== '') {
          output.push(`### Directory: ${directory}/`);
          output.push('');
        }

        for (const file of directoryFiles) {
          this.renderFile(file, output, effectiveConfig);
        }
      }
    } else {
      // Render files in order
      for (const file of files) {
        this.renderFile(file, output, effectiveConfig);
      }
    }

    return output.join('\n');
  }

  /**
   * Render a single file to Markdown
   * @param file File to render
   * @param output Output array to append to
   * @param config Renderer configuration
   */
  private renderFile(
    file: CollectedFile,
    output: string[],
    config: MarkdownRendererConfig
  ): void {
    const anchor = this.createAnchor(file.filePath);
    output.push(`### <a id="${anchor}"></a>${file.filePath}`);
    output.push('');

    // Add metadata if enabled
    if (config.includeMetadata && file.meta) {
      const metadataLines: string[] = [];

      if (file.meta.size !== undefined) {
        metadataLines.push(`Size: ${this.formatSize(file.meta.size)}`);
      }

      if (file.meta.lastModified) {
        metadataLines.push(`Last Modified: ${new Date(file.meta.lastModified).toISOString()}`);
      }

      if (file.meta.type) {
        metadataLines.push(`Type: ${file.meta.type}`);
      }

      if (metadataLines.length > 0) {
        output.push('**Metadata:**');
        for (const line of metadataLines) {
          output.push(`- ${line}`);
        }
        output.push('');
      }
    }

    // Add security warnings if enabled and present
    if (config.includeSecurityWarnings && file.meta?.securityIssues && file.meta.securityIssues.length > 0) {
      output.push('**Security Warnings:**');
      for (const issue of file.meta.securityIssues) {
        const severity = issue.severity || 'warning';
        output.push(`- **${severity.toUpperCase()}**: ${issue.message}`);
      }
      output.push('');
    }

    // Add file content with syntax highlighting based on extension
    const extension = path.extname(file.filePath).substring(1);
    const language = this.getLanguageForExtension(extension);

    if (config.includeLineNumbers) {
      // Add content with line numbers
      const lines = file.content.split('\n');
      const codeLines: string[] = [];

      for (let i = 0; i < lines.length; i++) {
        const lineNumber = i + 1;
        const paddedLineNumber = lineNumber.toString().padStart(4, ' ');
        codeLines.push(`${paddedLineNumber}: ${lines[i]}`);
      }

      output.push('```' + language);
      output.push(codeLines.join('\n'));
      output.push('```');
    } else {
      // Add content without line numbers
      output.push('```' + language);
      output.push(file.content);
      output.push('```');
    }

    output.push('');
  }

  /**
   * Group files by directory
   * @param files Files to group
   * @returns Files grouped by directory
   */
  private groupFilesByDirectory(files: CollectedFile[]): Record<string, CollectedFile[]> {
    const result: Record<string, CollectedFile[]> = {};

    for (const file of files) {
      const directory = path.dirname(file.filePath);

      if (!result[directory]) {
        result[directory] = [];
      }

      result[directory].push(file);
    }

    return result;
  }

  /**
   * Create an anchor ID from a file path
   * @param filePath File path
   * @returns Anchor ID
   */
  private createAnchor(filePath: string): string {
    return filePath
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .toLowerCase();
  }

  /**
   * Format file size in human-readable format
   * @param size Size in bytes
   * @returns Formatted size
   */
  private formatSize(size: number): string {
    if (size < 1024) {
      return `${size} bytes`;
    } else if (size < 1024 * 1024) {
      return `${(size / 1024).toFixed(2)} KB`;
    } else if (size < 1024 * 1024 * 1024) {
      return `${(size / (1024 * 1024)).toFixed(2)} MB`;
    } else {
      return `${(size / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }
  }

  /**
   * Get language identifier for syntax highlighting based on file extension
   * @param extension File extension
   * @returns Language identifier
   */
  private getLanguageForExtension(extension: string): string {
    const extensionMap: Record<string, string> = {
      // Programming languages
      'js': 'javascript',
      'jsx': 'jsx',
      'ts': 'typescript',
      'tsx': 'tsx',
      'py': 'python',
      'rb': 'ruby',
      'java': 'java',
      'c': 'c',
      'cpp': 'cpp',
      'cs': 'csharp',
      'go': 'go',
      'rs': 'rust',
      'php': 'php',
      'swift': 'swift',
      'kt': 'kotlin',
      'scala': 'scala',

      // Web technologies
      'html': 'html',
      'htm': 'html',
      'css': 'css',
      'scss': 'scss',
      'sass': 'sass',
      'less': 'less',
      'json': 'json',
      'xml': 'xml',
      'svg': 'svg',

      // Configuration files
      'yml': 'yaml',
      'yaml': 'yaml',
      'toml': 'toml',
      'ini': 'ini',
      'env': 'dotenv',

      // Shell scripts
      'sh': 'bash',
      'bash': 'bash',
      'zsh': 'bash',
      'bat': 'batch',
      'ps1': 'powershell',

      // Documentation
      'md': 'markdown',
      'markdown': 'markdown',
      'txt': 'text',

      // Other
      'sql': 'sql',
      'graphql': 'graphql',
      'dockerfile': 'dockerfile',
      'gitignore': 'gitignore'
    };

    return extensionMap[extension.toLowerCase()] || '';
  }

  /**
   * Get effective configuration with defaults
   * @param config User-provided configuration
   * @returns Effective configuration with defaults applied
   */
  private getEffectiveConfig(config?: MarkdownRendererConfig): MarkdownRendererConfig {
    return {
      includeMetadata: config?.includeMetadata !== false,
      includeTableOfContents: config?.includeTableOfContents !== false,
      includeSecurityWarnings: config?.includeSecurityWarnings !== false,
      includeLineNumbers: config?.includeLineNumbers || false,
      title: config?.title || 'Project Context',
      groupByDirectory: config?.groupByDirectory !== false
    };
  }

  /**
   * Clean up resources
   */
  async cleanup(): Promise<void> {
    // Nothing to clean up
  }
}

// Export plugin instance
export default new MarkdownRenderer();


[33m--- File: src/plugins/llm-reviewers/BaseLLMReviewer.ts (Size: 13503 bytes, 440 lines) ---[39m
// LLM Reviewer Plugin Interface
// This file defines the base class for LLM reviewer plugins

import * as path from 'path';
import * as fs from 'fs-extra';
import {
  Plugin,
  PluginType,
  LLMReviewerPlugin
} from '../PluginManager';
import { CollectedFile } from '../../types';

/**
 * Base configuration for LLM reviewers
 */
export interface BaseLLMReviewerConfig {
  /** Maximum content length to review (default: 100000) */
  maxContentLength?: number;

  /** Whether to include file metadata in review (default: true) */
  includeMetadata?: boolean;

  /** Whether to include security issues in review (default: true) */
  includeSecurityIssues?: boolean;

  /** Whether to generate summaries for individual files (default: true) */
  generateFileSummaries?: boolean;

  /** Whether to generate an overall project summary (default: true) */
  generateProjectSummary?: boolean;

  /** Custom prompt template for file review */
  fileReviewPrompt?: string;

  /** Custom prompt template for project summary */
  projectSummaryPrompt?: string;

  /** File patterns to exclude from review */
  excludePatterns?: string[];

  /** File patterns to include in review */
  includePatterns?: string[];

  /** Maximum number of files to review (default: 50) */
  maxFiles?: number;
}

/**
 * Abstract base class for LLM reviewer plugins
 * Provides common functionality for LLM reviewers
 */
export abstract class BaseLLMReviewer implements LLMReviewerPlugin {
  id: string;
  name: string;
  type: PluginType.LLM_REVIEWER = PluginType.LLM_REVIEWER;
  version: string;
  description: string;

  // Default prompts
  protected readonly DEFAULT_FILE_REVIEW_PROMPT =
    "Review the following file and identify any security issues, " +
    "potential improvements, or notable patterns. " +
    "Also provide a brief summary of the file's purpose and functionality.\n\n" +
    "File: {filePath}\n\n" +
    "{content}";

  protected readonly DEFAULT_PROJECT_SUMMARY_PROMPT =
    "Based on the files reviewed, provide a summary of the project. " +
    "Include information about the project structure, main components, " +
    "technologies used, and any security concerns or recommendations.\n\n" +
    "Files reviewed: {fileCount}\n\n" +
    "File summaries:\n{fileSummaries}";

  /**
   * Constructor
   * @param id Plugin ID
   * @param name Plugin name
   * @param version Plugin version
   * @param description Plugin description
   */
  constructor(
    id: string,
    name: string,
    version: string,
    description: string
  ) {
    this.id = id;
    this.name = name;
    this.version = version;
    this.description = description;
  }

  /**
   * Initialize the plugin
   * Must be implemented by subclasses
   */
  abstract initialize(): Promise<void>;

  /**
   * Check if the LLM is available
   * Must be implemented by subclasses
   */
  abstract isAvailable(): Promise<boolean>;

  /**
   * Review files using an LLM
   * @param files Files to review
   * @param config Configuration for the reviewer
   * @returns Reviewed files with additional metadata
   */
  async reviewFiles(files: CollectedFile[], config?: BaseLLMReviewerConfig): Promise<CollectedFile[]> {
    const effectiveConfig = this.getEffectiveConfig(config);

    // Filter files based on include/exclude patterns
    let filesToReview = this.filterFiles(files, effectiveConfig);

    // Limit number of files if needed
    if (effectiveConfig.maxFiles && filesToReview.length > effectiveConfig.maxFiles) {
      filesToReview = filesToReview.slice(0, effectiveConfig.maxFiles);
    }

    // Clone files to avoid modifying the original
    const result = [...files];
    const reviewedFiles = new Set<string>();

    // Process each file
    for (const file of filesToReview) {
      try {
        // Skip files that are too large
        if (file.content.length > (effectiveConfig.maxContentLength || 10000)) {
          console.warn(`Skipping file ${file.filePath} because it exceeds the maximum content length`);
          continue;
        }

        // Prepare prompt for file review
        const prompt = this.prepareFileReviewPrompt(file, effectiveConfig);

        // Get review from LLM
        const review = await this.reviewFile(prompt, file);

        // Find the file in the result array and update its metadata
        const resultFile = result.find(f => f.filePath === file.filePath);
        if (resultFile) {
          if (!resultFile.meta) {
            resultFile.meta = {};
          }

          if (!resultFile.meta.llmReviews) {
            resultFile.meta.llmReviews = {};
          }

          resultFile.meta.llmReviews[this.id] = review;
          reviewedFiles.add(file.filePath);
        }
      } catch (error) {
        console.error(`Error reviewing file ${file.filePath}:`, error);
      }
    }

    // Generate project summary if enabled
    if (effectiveConfig.generateProjectSummary) {
      try {
        const fileSummaries = result
          .filter(file => reviewedFiles.has(file.filePath))
          .map(file => {
            const review = file.meta?.llmReviews?.[this.id];
            return review?.summary || '';
          })
          .filter(Boolean)
          .join('\n\n');

        const prompt = this.prepareProjectSummaryPrompt(fileSummaries, reviewedFiles.size, effectiveConfig);
        const summary = await this.generateProjectSummary(prompt);

        // Add summary to all files
        for (const file of result) {
          if (!file.meta) {
            file.meta = {};
          }

          if (!file.meta.llmProjectSummary) {
            file.meta.llmProjectSummary = {};
          }

          file.meta.llmProjectSummary[this.id] = summary;
        }
      } catch (error) {
        console.error('Error generating project summary:', error);
      }
    }

    return result;
  }

  /**
   * Generate a summary of the files
   * @param files Files to summarize
   * @param config Configuration for the summarizer
   * @returns Summary text
   */
  async generateSummary(files: CollectedFile[], config?: BaseLLMReviewerConfig): Promise<string> {
    const effectiveConfig = this.getEffectiveConfig(config);

    // Filter files based on include/exclude patterns
    let filesToReview = this.filterFiles(files, effectiveConfig);

    // Limit number of files if needed
    if (effectiveConfig.maxFiles && filesToReview.length > effectiveConfig.maxFiles) {
      filesToReview = filesToReview.slice(0, effectiveConfig.maxFiles);
    }

    // Extract summaries from file reviews
    const fileSummaries: string[] = [];

    for (const file of filesToReview) {
      try {
        // Skip files that are too large
        if (file.content.length > (effectiveConfig.maxContentLength || 10000)) {
          continue;
        }

        // Check if file already has a review
        if (file.meta?.llmReviews?.[this.id]?.summary) {
          fileSummaries.push(`${file.filePath}: ${file.meta.llmReviews[this.id].summary}`);
          continue;
        }

        // Prepare prompt for file review
        const prompt = this.prepareFileReviewPrompt(file, effectiveConfig);

        // Get review from LLM
        const review = await this.reviewFile(prompt, file);

        if (review.summary) {
          fileSummaries.push(`${file.filePath}: ${review.summary}`);
        }
      } catch (error) {
        console.error(`Error reviewing file ${file.filePath}:`, error);
      }
    }

    // Generate project summary
    const summaryPrompt = this.prepareProjectSummaryPrompt(
      fileSummaries.join('\n\n'),
      filesToReview.length,
      effectiveConfig
    );

    return await this.generateProjectSummary(summaryPrompt);
  }

  /**
   * Review a file using the LLM
   * Must be implemented by subclasses
   * @param prompt Prompt for the LLM
   * @param file File being reviewed
   * @returns Review results
   */
  protected abstract reviewFile(
    prompt: string,
    file: CollectedFile
  ): Promise<{
    summary: string;
    securityIssues?: Array<{
      description: string;
      severity: string;
      recommendation?: string;
    }>;
    improvements?: string[];
    notes?: string[];
  }>;

  /**
   * Generate a project summary using the LLM
   * Must be implemented by subclasses
   * @param prompt Prompt for the LLM
   * @returns Project summary
   */
  protected abstract generateProjectSummary(prompt: string): Promise<string>;

  /**
   * Prepare prompt for file review
   * @param file File to review
   * @param config Configuration
   * @returns Prompt for the LLM
   */
  protected prepareFileReviewPrompt(file: CollectedFile, config: BaseLLMReviewerConfig): string {
    let prompt = config.fileReviewPrompt || this.DEFAULT_FILE_REVIEW_PROMPT;

    // Replace placeholders
    prompt = prompt.replace('{filePath}', file.filePath);
    prompt = prompt.replace('{content}', file.content);

    // Add metadata if enabled
    if (config.includeMetadata && file.meta) {
      let metadataStr = 'File Metadata:\n';

      if (file.meta.size !== undefined) {
        metadataStr += `Size: ${file.meta.size} bytes\n`;
      }

      if (file.meta.lastModified) {
        metadataStr += `Last Modified: ${new Date(file.meta.lastModified).toISOString()}\n`;
      }

      if (file.meta.type) {
        metadataStr += `Type: ${file.meta.type}\n`;
      }

      prompt = prompt.replace('{metadata}', metadataStr);
    } else {
      prompt = prompt.replace('{metadata}', '');
    }

    // Add security issues if enabled
    if (config.includeSecurityIssues && file.meta?.securityIssues) {
      let securityStr = 'Security Issues:\n';

      for (const issue of file.meta.securityIssues) {
        securityStr += `- ${issue.severity?.toUpperCase() || 'WARNING'}: ${issue.message}\n`;
        if (issue.details) {
          securityStr += `  ${issue.details}\n`;
        }
      }

      prompt = prompt.replace('{securityIssues}', securityStr);
    } else {
      prompt = prompt.replace('{securityIssues}', '');
    }

    return prompt;
  }

  /**
   * Prepare prompt for project summary
   * @param fileSummaries Summaries of individual files
   * @param fileCount Number of files reviewed
   * @param config Configuration
   * @returns Prompt for the LLM
   */
  protected prepareProjectSummaryPrompt(
    fileSummaries: string,
    fileCount: number,
    config: BaseLLMReviewerConfig
  ): string {
    let prompt = config.projectSummaryPrompt || this.DEFAULT_PROJECT_SUMMARY_PROMPT;

    // Replace placeholders
    prompt = prompt.replace('{fileCount}', fileCount.toString());
    prompt = prompt.replace('{fileSummaries}', fileSummaries);

    return prompt;
  }

  /**
   * Filter files based on include/exclude patterns
   * @param files Files to filter
   * @param config Configuration
   * @returns Filtered files
   */
  protected filterFiles(files: CollectedFile[], config: BaseLLMReviewerConfig): CollectedFile[] {
    let result = [...files];

    // Apply exclude patterns
    if (config.excludePatterns && config.excludePatterns.length > 0) {
      result = result.filter(file => !this.matchesAnyPattern(file.filePath, config.excludePatterns!));
    }

    // Apply include patterns
    if (config.includePatterns && config.includePatterns.length > 0) {
      result = result.filter(file => this.matchesAnyPattern(file.filePath, config.includePatterns!));
    }

    return result;
  }

  /**
   * Check if a file path matches any of the given patterns
   * @param filePath File path to check
   * @param patterns Patterns to match against
   * @returns Whether the file path matches any pattern
   */
  protected matchesAnyPattern(filePath: string, patterns: string[]): boolean {
    // Normalize path to use forward slashes
    const normalizedPath = filePath.replace(/\\/g, '/');

    for (const pattern of patterns) {
      if (this.matchesGlobPattern(normalizedPath, pattern)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Check if a path matches a glob pattern
   * @param path Path to check
   * @param pattern Glob pattern
   * @returns Whether the path matches the pattern
   */
  protected matchesGlobPattern(path: string, pattern: string): boolean {
    // Convert glob pattern to regex
    const regexPattern = pattern
      .replace(/\./g, '\\.')
      .replace(/\*\*/g, '.*')
      .replace(/\*/g, '[^/]*')
      .replace(/\?/g, '.');

    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(path);
  }

  /**
   * Get effective configuration with defaults
   * @param config User-provided configuration
   * @returns Effective configuration with defaults applied
   */
  protected getEffectiveConfig(config?: BaseLLMReviewerConfig): BaseLLMReviewerConfig {
    return {
      maxContentLength: config?.maxContentLength || 100000,
      includeMetadata: config?.includeMetadata !== false,
      includeSecurityIssues: config?.includeSecurityIssues !== false,
      generateFileSummaries: config?.generateFileSummaries !== false,
      generateProjectSummary: config?.generateProjectSummary !== false,
      fileReviewPrompt: config?.fileReviewPrompt || this.DEFAULT_FILE_REVIEW_PROMPT,
      projectSummaryPrompt: config?.projectSummaryPrompt || this.DEFAULT_PROJECT_SUMMARY_PROMPT,
      excludePatterns: config?.excludePatterns || [],
      includePatterns: config?.includePatterns || [],
      maxFiles: config?.maxFiles || 50
    };
  }

  /**
   * Clean up resources
   * Must be implemented by subclasses
   */
  abstract cleanup(): Promise<void>;
}


[33m--- File: src/plugins/llm-reviewers/LocalLLMReviewer.ts (Size: 12236 bytes, 428 lines) ---[39m
// Local LLM Reviewer Plugin
// This plugin uses a local LLM for reviewing code and generating summaries

import * as path from 'path';
import * as fs from 'fs-extra';
import { spawn } from 'child_process';
import { BaseLLMReviewer, BaseLLMReviewerConfig } from './BaseLLMReviewer';
import { CollectedFile, SecurityIssueSeverity } from '../../types';

/**
 * Configuration for Local LLM reviewer
 */
interface LocalLLMReviewerConfig extends BaseLLMReviewerConfig {
  /** Path to the LLM executable or script */
  modelPath?: string;

  /** Model name to use (if supported by the executable) */
  modelName?: string;

  /** Maximum tokens to generate */
  maxTokens?: number;

  /** Temperature for generation */
  temperature?: number;

  /** Additional arguments to pass to the LLM executable */
  additionalArgs?: string[];

  /** Timeout in milliseconds for LLM operations */
  timeout?: number;
}

/**
 * Local LLM Reviewer Plugin
 * Uses a locally installed LLM for reviewing code and generating summaries
 */
export class LocalLLMReviewer extends BaseLLMReviewer {
  // Default paths to check for LLM executables
  private readonly DEFAULT_LLM_PATHS = [
    // Ollama
    '/usr/local/bin/ollama',
    '/usr/bin/ollama',
    // LLama.cpp
    '/usr/local/bin/llama',
    '/usr/bin/llama',
    // GPT4All
    '/usr/local/bin/gpt4all',
    '/usr/bin/gpt4all',
  ];

  // Default model names
  private readonly DEFAULT_MODEL_NAMES = {
    'ollama': 'codellama',
    'llama': 'codellama-7b-instruct.Q4_K_M.gguf',
    'gpt4all': 'ggml-model-gpt4all-falcon-q4_0.bin'
  };

  private modelPath: string = '';
  private modelType: string = '';
  private modelName: string = '';
  private isModelAvailable: boolean = false;

  /**
   * Constructor
   */
  constructor() {
    super(
      'local-llm-reviewer',
      'Local LLM Reviewer',
      '1.0.0',
      'Uses a locally installed LLM for reviewing code and generating summaries'
    );
  }

  /**
   * Initialize the plugin
   */
  async initialize(): Promise<void> {
    // Find LLM executable
    await this.findLLM();
  }

  /**
   * Check if the LLM is available
   */
  async isAvailable(): Promise<boolean> {
    return this.isModelAvailable;
  }

  /**
   * Find LLM executable
   */
  private async findLLM(): Promise<void> {
    // Check if model path is already set and valid
    if (this.modelPath && await fs.pathExists(this.modelPath)) {
      this.isModelAvailable = true;
      return;
    }

    // Check default paths
    for (const llmPath of this.DEFAULT_LLM_PATHS) {
      if (await fs.pathExists(llmPath)) {
        this.modelPath = llmPath;
        this.modelType = path.basename(llmPath);
        this.modelName = this.DEFAULT_MODEL_NAMES[this.modelType as keyof typeof this.DEFAULT_MODEL_NAMES] || '';

        // Verify the model works
        try {
          await this.testLLM();
          this.isModelAvailable = true;
          console.log(`Found working LLM at ${this.modelPath}`);
          return;
        } catch (error) {
          console.warn(`Found LLM at ${this.modelPath} but it failed the test:`, error instanceof Error ? error.message : String(error));
        }
      }
    }

    console.warn('No working LLM found');
    this.isModelAvailable = false;
  }

  /**
   * Test if the LLM works
   */
  private async testLLM(): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      const testPrompt = 'Say hello';
      let args: string[] = [];

      // Prepare arguments based on model type
      if (this.modelType === 'ollama') {
        args = ['run', this.modelName, testPrompt];
      } else if (this.modelType === 'llama') {
        args = ['-m', this.modelName, '-p', testPrompt, '--temp', '0.7', '-n', '10'];
      } else if (this.modelType === 'gpt4all') {
        args = ['-m', this.modelName, '-p', testPrompt];
      } else {
        reject(new Error(`Unsupported model type: ${this.modelType}`));
        return;
      }

      // Run the LLM with a timeout
      const process = spawn(this.modelPath, args);

      let output = '';
      let error = '';

      process.stdout.on('data', (data) => {
        output += data.toString();
      });

      process.stderr.on('data', (data) => {
        error += data.toString();
      });

      const timeout = setTimeout(() => {
        process.kill();
        reject(new Error('LLM test timed out'));
      }, 10000);

      process.on('close', (code) => {
        clearTimeout(timeout);

        if (code === 0 && output.length > 0) {
          resolve();
        } else {
          reject(new Error(`LLM test failed with code ${code}: ${error}`));
        }
      });
    });
  }

  /**
   * Review a file using the LLM
   * @param prompt Prompt for the LLM
   * @param file File being reviewed
   * @returns Review results
   */
  protected async reviewFile(
    prompt: string,
    file: CollectedFile
  ): Promise<{
    summary: string;
    securityIssues?: Array<{
      description: string;
      severity: string;
      recommendation?: string;
    }>;
    improvements?: string[];
    notes?: string[];
  }> {
    // Run LLM with the prompt
    const response = await this.runLLM(prompt, {
      maxTokens: 1000,
      temperature: 0.3
    });

    // Parse the response
    return this.parseReviewResponse(response);
  }

  /**
   * Generate a project summary using the LLM
   * @param prompt Prompt for the LLM
   * @returns Project summary
   */
  protected async generateProjectSummary(prompt: string): Promise<string> {
    // Run LLM with the prompt
    return await this.runLLM(prompt, {
      maxTokens: 2000,
      temperature: 0.7
    });
  }

  /**
   * Run the LLM with a prompt
   * @param prompt Prompt for the LLM
   * @param options Options for the LLM
   * @returns LLM response
   */
  private async runLLM(
    prompt: string,
    options: {
      maxTokens?: number;
      temperature?: number;
    } = {}
  ): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      if (!this.isModelAvailable) {
        reject(new Error('LLM is not available'));
        return;
      }

      let args: string[] = [];

      // Prepare arguments based on model type
      if (this.modelType === 'ollama') {
        args = ['run', this.modelName, prompt];

        if (options.temperature !== undefined) {
          args.push('--temperature');
          args.push(options.temperature.toString());
        }

        if (options.maxTokens !== undefined) {
          args.push('--num-predict');
          args.push(options.maxTokens.toString());
        }
      } else if (this.modelType === 'llama') {
        args = ['-m', this.modelName, '-p', prompt];

        if (options.temperature !== undefined) {
          args.push('--temp');
          args.push(options.temperature.toString());
        }

        if (options.maxTokens !== undefined) {
          args.push('-n');
          args.push(options.maxTokens.toString());
        }
      } else if (this.modelType === 'gpt4all') {
        args = ['-m', this.modelName, '-p', prompt];

        if (options.temperature !== undefined) {
          args.push('--temp');
          args.push(options.temperature.toString());
        }

        if (options.maxTokens !== undefined) {
          args.push('--tokens');
          args.push(options.maxTokens.toString());
        }
      } else {
        reject(new Error(`Unsupported model type: ${this.modelType}`));
        return;
      }

      // Run the LLM with a timeout
      const process = spawn(this.modelPath, args);

      let output = '';
      let error = '';

      process.stdout.on('data', (data) => {
        output += data.toString();
      });

      process.stderr.on('data', (data) => {
        error += data.toString();
      });

      const timeout = setTimeout(() => {
        process.kill();
        reject(new Error('LLM operation timed out'));
      }, 60000); // 1 minute timeout

      process.on('close', (code) => {
        clearTimeout(timeout);

        if (code === 0) {
          resolve(output.trim());
        } else {
          reject(new Error(`LLM operation failed with code ${code}: ${error}`));
        }
      });
    });
  }

  /**
   * Parse the LLM response for a file review
   * @param response LLM response
   * @returns Parsed review
   */
  private parseReviewResponse(response: string): {
    summary: string;
    meta?: {
      securityIssues?: Array<{
        description: string;
        severity: SecurityIssueSeverity;
        recommendation?: string;
      }>;
      improvements?: string[];
      notes?: string[];
    };
  } {
    // Default result
    const result = {
      summary: '',
      meta: {
        securityIssues: [] as Array<{
          description: string;
          severity: SecurityIssueSeverity;
          recommendation?: string;
        }>,
        improvements: [] as string[],
        notes: [] as string[]
      }
    };

    // Try to extract structured information
    const summaryMatch = response.match(/(?:Summary|SUMMARY):\s*(.*?)(?:\n\n|\n(?:Security|SECURITY)|$)/s);
    if (summaryMatch) {
      result.summary = summaryMatch[1].trim();
    } else {
      // If no summary section, use the first paragraph as summary
      const firstParagraph = response.split('\n\n')[0];
      result.summary = firstParagraph.trim();
    }

    // Extract security issues
    const securitySection = response.match(/(?:Security Issues|SECURITY ISSUES|Security|SECURITY):\s*(.*?)(?:\n\n|\n(?:Improvements|IMPROVEMENTS)|$)/s);
    if (securitySection) {
      const securityText = securitySection[1].trim();
      const issues = securityText.split(/\n\s*-\s*/).filter(Boolean);

      for (const issue of issues) {
        if (!issue.trim()) continue;

        // Try to extract severity
        const severityMatch = issue.match(/\b(critical|high|medium|low|info)\b/i);
        const severityStr = severityMatch ? severityMatch[1].toLowerCase() : 'medium';
        const severity = severityStr === 'critical' ? SecurityIssueSeverity.CRITICAL :
          severityStr === 'high' ? SecurityIssueSeverity.HIGH :
          severityStr === 'medium' ? SecurityIssueSeverity.MEDIUM :
          severityStr === 'low' ? SecurityIssueSeverity.LOW :
          severityStr === 'info' ? SecurityIssueSeverity.INFO :
          SecurityIssueSeverity.MEDIUM;

        // Try to extract recommendation
        const recommendationMatch = issue.match(/(?:Recommendation|Recommended|Suggest|Fix):\s*(.*?)(?:$)/s);
        const recommendation = recommendationMatch ? recommendationMatch[1].trim() : undefined;

        result.meta.securityIssues.push({
          description: issue.trim(),
          severity,
          recommendation
        });
      }
    }

    // Extract improvements
    const improvementsSection = response.match(/(?:Improvements|IMPROVEMENTS|Suggestions|SUGGESTIONS):\s*(.*?)(?:\n\n|\n(?:Notes|NOTES)|$)/s);
    if (improvementsSection) {
      const improvementsText = improvementsSection[1].trim();
      result.meta.improvements = improvementsText.split(/\n\s*-\s*/).filter(Boolean).map(i => i.trim());
    }

    // Extract notes
    const notesSection = response.match(/(?:Notes|NOTES|Additional|ADDITIONAL):\s*(.*?)(?:\n\n|$)/s);
    if (notesSection) {
      const notesText = notesSection[1].trim();
      result.meta.notes = notesText.split(/\n\s*-\s*/).filter(Boolean).map(n => n.trim());
    }

    return result;
  }

  /**
   * Get effective configuration with defaults
   * @param config User-provided configuration
   * @returns Effective configuration with defaults applied
   */
  protected getEffectiveConfig(config?: LocalLLMReviewerConfig): LocalLLMReviewerConfig {
    const baseConfig = super.getEffectiveConfig(config);

    return {
      ...baseConfig,
      modelPath: config?.modelPath || this.modelPath,
      modelName: config?.modelName || this.modelName,
      maxTokens: config?.maxTokens || 1000,
      temperature: config?.temperature || 0.7,
      additionalArgs: config?.additionalArgs || [],
      timeout: config?.timeout || 60000
    };
  }

  /**
   * Clean up resources
   */
  async cleanup(): Promise<void> {
    // Nothing to clean up
  }
}

// Export plugin instance
export default new LocalLLMReviewer();


[33m--- File: src/types/chalk.d.ts (Size: 900 bytes, 36 lines) ---[39m
// Type definitions for chalk
declare module 'chalk' {
  interface ChalkFunction {
    (text: string): string;
    bold: ChalkFunction;
    blue: ChalkFunction;
    green: ChalkFunction;
    red: ChalkFunction;
    yellow: ChalkFunction;
    magenta: ChalkFunction;
    cyan: ChalkFunction;
    white: ChalkFunction;
    gray: ChalkFunction;
    grey: ChalkFunction;
    black: ChalkFunction;
    blueBright: ChalkFunction;
    redBright: ChalkFunction;
    greenBright: ChalkFunction;
    yellowBright: ChalkFunction;
    magentaBright: ChalkFunction;
    cyanBright: ChalkFunction;
    whiteBright: ChalkFunction;
    bgBlack: ChalkFunction;
    bgRed: ChalkFunction;
    bgGreen: ChalkFunction;
    bgYellow: ChalkFunction;
    bgBlue: ChalkFunction;
    bgMagenta: ChalkFunction;
    bgCyan: ChalkFunction;
    bgWhite: ChalkFunction;
  }

  const chalk: ChalkFunction;
  export default chalk;
}


[33m--- File: src/types/express.d.ts (Size: 785 bytes, 28 lines) ---[39m
// Type definitions for express
declare module 'express' {
  namespace express {
    interface Request {
      query: any;
      body: any;
    }

    interface Response {
      sendFile(path: string): void;
      json(data: any): void;
      status(code: number): Response;
    }

    interface Application {
      use(middleware: any): void;
      get(path: string, handler: (req: Request, res: Response) => void): void;
      post(path: string, handler: (req: Request, res: Response) => void): void;
      delete(path: string, handler: (req: Request, res: Response) => void): void;
      listen(port: number, host: string, callback: () => void): any;
      listen(port: number, callback: () => void): any;
    }
  }

  function express(): express.Application;
  export = express;
}


[33m--- File: src/types/fast-glob.d.ts (Size: 469 bytes, 18 lines) ---[39m
// Type definitions for fast-glob
declare module 'fast-glob' {
  namespace fastGlob {
    interface Options {
      onlyFiles?: boolean;
      deep?: number | boolean;
      [key: string]: any;
    }
    
    function sync(patterns: string | string[], options?: Options): string[];
    function isDynamicPattern(pattern: string): boolean;
  }
  
  function fastGlob(patterns: string | string[], options?: fastGlob.Options): Promise<string[]>;
  
  export = fastGlob;
}


[33m--- File: src/types/index.ts (Size: 4753 bytes, 181 lines) ---[39m
export interface IncludeDirConfig {
    path: string;
    include: string[];
    exclude?: string[];
    recursive: boolean;
    useRegex?: boolean;
  }

  export interface FileCollectorConfig {
    name?: string;
    showContents?: boolean;
    showMeta?: boolean;
    includeDirs?: IncludeDirConfig[];
    includeFiles?: string[];
    excludeFiles?: string[];
    useRegex?: boolean;
    searchInFiles?: {
      pattern: string;
      isRegex: boolean;
    };
    listOnlyFiles?: string[];
  }

  export interface CollectedFile {
    filePath: string;
    relativePath?: string;
    content: string;
    fileSize?: number;
    lineCount?: number;
    meta?: {
      size?: number;
      lastModified?: number;
      type?: string;
      securityIssues?: SecurityIssue[];
      securityTransformed?: boolean;
      securityTransformedReason?: string;
      llmReviews?: Record<string, any>;
      llmProjectSummary?: Record<string, any>;
      isListOnly?: boolean;
      error?: string;
      [key: string]: any;
    };
  }

  export enum SecurityIssueSeverity {
    LOW = 'low',
    MEDIUM = 'medium',
    HIGH = 'high',
    CRITICAL = 'critical',
    INFO = 'info',
    WARNING = 'warning',
    ERROR = 'error'
  }

  export interface SecurityIssue {
    description: string;
    severity: SecurityIssueSeverity;
    filePath?: string;
    line?: number;
    column?: number;
    code?: string;
    recommendation?: string;
    scanner?: string;
    remediation?: string;
    content?: string;
    [key: string]: any;
  }

  export interface FileContext {
    config: FileCollectorConfig;
    files: CollectedFile[];
    output?: string;
    totalFiles?: number;
    totalSize?: number;
  }

  export interface PluginEnabledConfig extends FileCollectorConfig {
    enablePlugins?: boolean;
    securityScanners?: string[];
    securityScannerConfig?: any;
    outputRenderers?: string[];
    outputRendererConfig?: any;
    llmReviewers?: string[];
    llmReviewerConfig?: any;
    generateSecurityReports?: boolean;
    generateSummaries?: boolean;
  }

  export interface PluginEnabledBuildResult extends FileContext {
    securityReports?: any[];
    summaries?: Record<string, any>;
  }

  export enum PluginType {
    SECURITY_SCANNER = 'security-scanner',
    OUTPUT_RENDERER = 'output-renderer',
    LLM_REVIEWER = 'llm-reviewer'
  }

  export interface Plugin {
    id: string;
    name: string;
    description: string;
    type: PluginType;
    version: string;
    author?: string;
    homepage?: string;
    isEnabled: boolean;
    isAvailable?(): Promise<boolean>;
    initialize?(): Promise<void>;
    cleanup?(): Promise<void>;
  }

  export interface SecurityScannerPlugin extends Plugin {
    type: PluginType.SECURITY_SCANNER;

    /**
     * Scan files for security issues
     * @param files Files to scan
     * @param config Configuration for the scanner
     * @returns Files with security warnings added to metadata
     */
    scan(files: CollectedFile[], config?: any): Promise<CollectedFile[]>;

    /**
     * Get security warnings as a separate report
     * @param files Files to scan
     * @param config Configuration for the scanner
     * @returns Security report
     */
    generateSecurityReport?(files: CollectedFile[], config?: any): Promise<any>;

    /**
     * Alternative method name for scanning files
     * @deprecated Use scan instead
     */
    scanFiles?(files: CollectedFile[], config?: any): Promise<CollectedFile[]>;
  }

  export interface OutputRendererPlugin extends Plugin {
    type: PluginType.OUTPUT_RENDERER;

    /**
     * Render files to a specific output format
     * @param context Context containing files to render
     * @param config Configuration for the renderer
     * @returns Rendered output
     */
    render(context: FileContext | { files: CollectedFile[] }, config?: any): string | Promise<string>;

    /**
     * Get the format name for this renderer
     */
    getFormatName(): string;
  }

  export interface LLMReviewerPlugin extends Plugin {
    type: PluginType.LLM_REVIEWER;

    /**
     * Review files using an LLM
     * @param files Files to review
     * @param config Configuration for the reviewer
     * @returns Files with review comments added to metadata
     */
    reviewFiles(files: CollectedFile[], config?: any): Promise<CollectedFile[]>;

    /**
     * Generate a summary of the review
     * @param files Files that were reviewed
     * @param config Configuration for the reviewer
     * @returns Summary of the review
     */
    generateSummary?(files: CollectedFile[], config?: any): Promise<any>;

    /**
     * Check if the LLM is available
     * @returns True if the LLM is available
     */
    isAvailable(): Promise<boolean>;
  }

[33m--- File: src/types/other-modules.d.ts (Size: 871 bytes, 32 lines) ---[39m
// Type definitions for other modules
declare module 'body-parser' {
  function json(): any;
  function urlencoded(options: { extended: boolean }): any;
  export { json, urlencoded };
}

declare module 'open' {
  function open(target: string, options?: any): Promise<any>;
  export default open;
}

declare module 'commander' {
  class Command {
    name(name: string): Command;
    description(desc: string): Command;
    version(version: string): Command;
    command(name: string): Command;
    option(flags: string, description: string, defaultValue?: any): Command;
    action(fn: (...args: any[]) => void): Command;
    parse(argv: string[]): Command;
    help(): void;
    on(event: string, listener: (...args: any[]) => void): Command;
    commands: Command[];
    name(): string;
  }

  function createCommand(): Command;

  export { Command, createCommand };
}


[33m--- File: src/plugins/security-scanners/GitIgnoreSecurityScanner.ts (Size: 12244 bytes, 409 lines) ---[39m
// GitIgnore Security Scanner Plugin
// This plugin scans files based on .gitignore patterns

import * as fs from 'fs-extra';
import * as path from 'path';
import * as glob from 'fast-glob';
import {
  Plugin,
  PluginType,
  SecurityScannerPlugin,
  SecurityReport,
  SecurityIssue,
  SecurityIssueSeverity
} from '../PluginManager';
import { CollectedFile } from '../../types';

/**
 * Configuration for GitIgnore scanner
 */
interface GitIgnoreScannerConfig {
  /** Path to .gitignore file (default: auto-detect) */
  gitignorePath?: string;

  /** Whether to use global gitignore (default: true) */
  useGlobalGitignore?: boolean;

  /** Whether to warn about files that should be ignored (default: true) */
  warnAboutIgnoredFiles?: boolean;

  /** Severity level for ignored files (default: warning) */
  ignoredFileSeverity?: SecurityIssueSeverity;
}

/**
 * GitIgnore Security Scanner Plugin
 * Scans files based on .gitignore patterns to identify files that should be excluded
 */
export class GitIgnoreSecurityScanner implements SecurityScannerPlugin {
  id = 'gitignore-scanner';
  name = 'GitIgnore Security Scanner';
  type: PluginType.SECURITY_SCANNER = PluginType.SECURITY_SCANNER;
  version = '1.0.0';
  description = 'Scans files based on .gitignore patterns to identify files that should be excluded';

  private gitignorePatterns: string[] = [];
  private gitignorePath: string = '';

  /**
   * Initialize the plugin
   */
  async initialize(): Promise<void> {
    // Default initialization - actual patterns will be loaded during scan
  }

  /**
   * Scan files for security issues based on .gitignore patterns
   * @param files Files to scan
   * @param config Configuration for the scanner
   * @returns Files with security warnings added to metadata
   */
  async scanFiles(files: CollectedFile[], config?: GitIgnoreScannerConfig): Promise<CollectedFile[]> {
    const effectiveConfig = this.getEffectiveConfig(config);

    // Load gitignore patterns
    await this.loadGitignorePatterns(effectiveConfig);

    if (this.gitignorePatterns.length === 0) {
      console.warn('No .gitignore patterns found');
      return files;
    }

    // Clone files to avoid modifying the original
    const result = [...files];

    // Check each file against gitignore patterns
    for (const file of result) {
      if (this.shouldBeIgnored(file.filePath)) {
        // Add security warning to file metadata
        if (!file.meta) {
          file.meta = {};
        }

        if (!file.meta.securityIssues) {
          file.meta.securityIssues = [];
        }

        file.meta.securityIssues.push({
          scanner: this.id,
          severity: effectiveConfig.ignoredFileSeverity || SecurityIssueSeverity.WARNING,
          description: `File matches .gitignore pattern and should be excluded`,
          details: `This file matches a pattern in ${this.gitignorePath} and might contain sensitive information.`
        });
      }
    }

    return result;
  }

  /**
   * Generate a security report for files
   * @param files Files to scan
   * @param config Configuration for the scanner
   * @returns Security report
   */
  async generateSecurityReport(files: CollectedFile[], config?: GitIgnoreScannerConfig): Promise<SecurityReport> {
    const effectiveConfig = this.getEffectiveConfig(config);

    // Load gitignore patterns if not already loaded
    await this.loadGitignorePatterns(effectiveConfig);

    const issues: SecurityIssue[] = [];
    let filesWithIssues = 0;

    // Check each file against gitignore patterns
    for (const file of files) {
      if (this.shouldBeIgnored(file.filePath)) {
        issues.push({
          filePath: file.filePath,
          severity: effectiveConfig.ignoredFileSeverity || SecurityIssueSeverity.WARNING,
          description: `File matches .gitignore pattern and should be excluded`,
          remediation: `Consider removing this file from the context or checking if it contains sensitive information.`
        });

        filesWithIssues++;
      }
    }

    // Count issues by severity
    const issuesBySeverity = issues.reduce((acc, issue) => {
      acc[issue.severity] = (acc[issue.severity] || 0) + 1;
      return acc;
    }, {} as Record<SecurityIssueSeverity, number>);

    return {
      scannerId: this.id,
      issues,
      summary: {
        totalFiles: files.length,
        filesWithIssues,
        issuesBySeverity
      }
    };
  }

  /**
   * Load gitignore patterns from file
   * @param config Scanner configuration
   */
  private async loadGitignorePatterns(config: GitIgnoreScannerConfig): Promise<void> {
    // Reset patterns
    this.gitignorePatterns = [];

    // Try to find .gitignore file
    let gitignorePath = config.gitignorePath;

    if (!gitignorePath) {
      // Auto-detect .gitignore in current directory
      const currentDir = process.cwd();
      const possiblePath = path.join(currentDir, '.gitignore');

      if (await fs.pathExists(possiblePath)) {
        gitignorePath = possiblePath;
      }
    }

    // Load from specified or detected path
    if (gitignorePath && await fs.pathExists(gitignorePath)) {
      this.gitignorePath = gitignorePath;
      const content = await fs.readFile(gitignorePath, 'utf8');
      this.parseGitignoreContent(content);
    }

    // Load global gitignore if enabled
    if (config.useGlobalGitignore) {
      try {
        const globalGitignorePath = await this.findGlobalGitignore();
        if (globalGitignorePath && await fs.pathExists(globalGitignorePath)) {
          const content = await fs.readFile(globalGitignorePath, 'utf8');
          this.parseGitignoreContent(content);

          // Update path info to include global
          if (this.gitignorePath) {
            this.gitignorePath += ` and global gitignore (${globalGitignorePath})`;
          } else {
            this.gitignorePath = globalGitignorePath;
          }
        }
      } catch (error) {
        console.warn('Error loading global gitignore:', error instanceof Error ? error.message : String(error));
      }
    }
  }

  /**
   * Parse gitignore content and extract patterns
   * @param content Gitignore file content
   */
  private parseGitignoreContent(content: string): void {
    const lines = content.split('\n');

    for (let line of lines) {
      // Remove comments
      const commentIndex = line.indexOf('#');
      if (commentIndex >= 0) {
        line = line.substring(0, commentIndex);
      }

      // Trim whitespace
      line = line.trim();

      // Skip empty lines
      if (!line) {
        continue;
      }

      // Add pattern
      this.gitignorePatterns.push(line);
    }
  }

  /**
   * Find global gitignore file
   * @returns Path to global gitignore file
   */
  private async findGlobalGitignore(): Promise<string | null> {
    try {
      // Try to get global gitignore from git config
      const { execSync } = require('child_process');
      const output = execSync('git config --global core.excludesfile', { encoding: 'utf8' }).trim();

      if (output && await fs.pathExists(output)) {
        return output;
      }

      // Check common locations
      const homeDir = process.env.HOME || process.env.USERPROFILE;
      if (homeDir) {
        const commonLocations = [
          path.join(homeDir, '.gitignore_global'),
          path.join(homeDir, '.gitignore'),
          path.join(homeDir, '.config', 'git', 'ignore')
        ];

        for (const location of commonLocations) {
          if (await fs.pathExists(location)) {
            return location;
          }
        }
      }
    } catch (error) {
      console.warn('Error finding global gitignore:', error instanceof Error ? error.message : String(error));
    }

    return null;
  }

  /**
   * Check if a file should be ignored based on gitignore patterns
   * @param filePath File path to check
   * @returns Whether the file should be ignored
   */
  private shouldBeIgnored(filePath: string): boolean {
    // Normalize path to use forward slashes
    const normalizedPath = filePath.replace(/\\/g, '/');

    for (const pattern of this.gitignorePatterns) {
      // Skip negated patterns (those starting with !)
      if (pattern.startsWith('!')) {
        continue;
      }

      // Convert gitignore pattern to glob pattern
      const globPattern = this.gitignoreToGlob(pattern);

      // Check if file matches pattern
      if (glob.isDynamicPattern(globPattern)) {
        if (this.matchGlobPattern(normalizedPath, globPattern)) {
          return true;
        }
      } else {
        // Simple string comparison for non-glob patterns
        if (normalizedPath.includes(pattern)) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * Convert gitignore pattern to glob pattern
   * @param pattern Gitignore pattern
   * @returns Glob pattern
   */
  /**
   * Match a file path against a glob pattern
   * @param filePath The file path to match
   * @param pattern The glob pattern to match against
   * @returns True if the file path matches the pattern
   */
  /**
   * Simple glob pattern matching
   * @param filePath The file path to match
   * @param pattern The glob pattern to match against
   * @returns True if the file path matches the pattern
   */
  private simpleGlobMatch(filePath: string, pattern: string): boolean {
    // Convert glob pattern to regex
    const regexPattern = pattern
      .replace(/\./g, '\\.')
      .replace(/\*/g, '.*')
      .replace(/\?/g, '.')
      .replace(/\[\!([^\]]+)\]/g, '[^$1]');

    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(filePath);
  }

  private matchGlobPattern(filePath: string, pattern: string): boolean {
    try {
      // Use minimatch for glob pattern matching
      return glob.isDynamicPattern(pattern) && this.simpleGlobMatch(filePath, pattern);
    } catch (error) {
      console.warn(`Invalid glob pattern: ${pattern}`);
      return false;
    }
  }

  /**
   * Check if a file should be ignored
   * @param filePath The file path to check
   * @returns True if the file should be ignored
   */
  public isIgnored(filePath: string): boolean {
    return this.shouldBeIgnored(filePath);
  }

  /**
   * Parse gitignore file content
   * @param content Gitignore file content
   * @returns Array of gitignore patterns
   */
  private parseGitignore(content: string): string[] {
    return content
      .split('\n')
      .map(line => line.trim())
      .filter(line => line && !line.startsWith('#'));
  }

  public async loadGitIgnoreFiles(gitIgnoreFiles: string[]): Promise<void> {
    this.gitignorePatterns = [];

    for (const gitIgnorePath of gitIgnoreFiles) {
      try {
        const content = await fs.readFile(gitIgnorePath, 'utf8');
        const patterns = this.parseGitignore(content);
        this.gitignorePatterns.push(...patterns);
      } catch (error) {
        console.warn(`Error loading gitignore file ${gitIgnorePath}:`, error);
      }
    }
  }

  private gitignoreToGlob(pattern: string): string {
    // Remove leading slash if present
    let result = pattern.startsWith('/') ? pattern.substring(1) : pattern;

    // Handle directory-only pattern (ending with /)
    if (result.endsWith('/')) {
      result = `${result}**`;
    }

    // Handle ** pattern
    if (!result.includes('**')) {
      // If pattern doesn't include a slash, it matches files in any directory
      if (!result.includes('/')) {
        result = `**/${result}`;
      }
    }

    return result;
  }

  /**
   * Get effective configuration with defaults
   * @param config User-provided configuration
   * @returns Effective configuration with defaults applied
   */
  private getEffectiveConfig(config?: GitIgnoreScannerConfig): GitIgnoreScannerConfig {
    return {
      gitignorePath: config?.gitignorePath,
      useGlobalGitignore: config?.useGlobalGitignore !== false,
      warnAboutIgnoredFiles: config?.warnAboutIgnoredFiles !== false,
      ignoredFileSeverity: config?.ignoredFileSeverity || SecurityIssueSeverity.WARNING
    };
  }

  /**
   * Clean up resources
   */
  async cleanup(): Promise<void> {
    // Nothing to clean up
  }
}

// Export plugin instance
export default new GitIgnoreSecurityScanner();


[33m--- File: src/plugins/security-scanners/SensitiveDataSecurityScanner.ts (Size: 12916 bytes, 440 lines) ---[39m
// Sensitive Data Security Scanner Plugin
// This plugin scans files for sensitive data patterns like API keys, passwords, etc.

import * as fs from 'fs-extra';
import * as path from 'path';
import {
  Plugin,
  PluginType,
  SecurityScannerPlugin,
  SecurityReport,
  SecurityIssue,
  SecurityIssueSeverity
} from '../PluginManager';
import { CollectedFile } from '../../types';

/**
 * Configuration for Sensitive Data scanner
 */
interface SensitiveDataScannerConfig {
  /** Custom patterns to scan for (in addition to built-in patterns) */
  customPatterns?: Array<{
    name: string;
    pattern: string;
    severity: SecurityIssueSeverity;
  }>;

  /** Whether to redact sensitive data in reports (default: true) */
  redactSensitiveData?: boolean;

  /** Whether to scan env files (default: true) */
  scanEnvFiles?: boolean;

  /** Whether to only include env file keys without values (default: true) */
  envFilesKeysOnly?: boolean;

  /** File patterns to treat as env files */
  envFilePatterns?: string[];
}

/**
 * Sensitive Data Security Scanner Plugin
 * Scans files for sensitive data patterns like API keys, passwords, etc.
 */
export class SensitiveDataSecurityScanner implements SecurityScannerPlugin {
  id = 'sensitive-data-scanner';
  name = 'Sensitive Data Security Scanner';
  type: PluginType.SECURITY_SCANNER = PluginType.SECURITY_SCANNER;
  version = '1.0.0';
  description = 'Scans files for sensitive data patterns like API keys, passwords, and other credentials';

  // Built-in patterns for sensitive data
  private readonly builtInPatterns = [
    {
      name: 'AWS Access Key',
      pattern: '(?<![A-Za-z0-9/+=])[A-Za-z0-9/+=]{40}(?![A-Za-z0-9/+=])',
      severity: SecurityIssueSeverity.CRITICAL
    },
    {
      name: 'AWS Secret Key',
      pattern: '(?<![A-Za-z0-9/+=])[A-Za-z0-9/+=]{20}(?![A-Za-z0-9/+=])',
      severity: SecurityIssueSeverity.CRITICAL
    },
    {
      name: 'Google API Key',
      pattern: 'AIza[0-9A-Za-z\\-_]{35}',
      severity: SecurityIssueSeverity.CRITICAL
    },
    {
      name: 'GitHub Token',
      pattern: 'gh[pousr]_[A-Za-z0-9_]{36}',
      severity: SecurityIssueSeverity.CRITICAL
    },
    {
      name: 'Generic API Key',
      pattern: '(?i)(api_key|apikey|api token|access_token)(.{0,20})[\'"][0-9a-zA-Z]{16,}[\'"]',
      severity: SecurityIssueSeverity.ERROR
    },
    {
      name: 'Generic Secret',
      pattern: '(?i)(secret|password|credentials)(.{0,20})[\'"][0-9a-zA-Z]{8,}[\'"]',
      severity: SecurityIssueSeverity.ERROR
    },
    {
      name: 'Private Key',
      pattern: '-----BEGIN (?:RSA|DSA|EC|OPENSSH) PRIVATE KEY-----',
      severity: SecurityIssueSeverity.CRITICAL
    },
    {
      name: 'Connection String',
      pattern: '(?i)(mongodb|postgresql|mysql|jdbc|redis)://[^\\s]+',
      severity: SecurityIssueSeverity.ERROR
    },
    {
      name: 'IP Address',
      pattern: '\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b',
      severity: SecurityIssueSeverity.INFO
    }
  ];

  // Default env file patterns
  private readonly defaultEnvFilePatterns = [
    '**/.env',
    '**/.env.*',
    '**/config/secrets.*',
    '**/credentials.*'
  ];

  /**
   * Initialize the plugin
   */
  async initialize(): Promise<void> {
    // Nothing to initialize
  }

  /**
   * Scan files for sensitive data
   * @param files Files to scan
   * @param config Configuration for the scanner
   * @returns Files with security warnings added to metadata
   */
  async scanFiles(files: CollectedFile[], config?: SensitiveDataScannerConfig): Promise<CollectedFile[]> {
    const effectiveConfig = this.getEffectiveConfig(config);

    // Combine built-in and custom patterns
    const patterns = [
      ...this.builtInPatterns,
      ...(effectiveConfig.customPatterns || [])
    ];

    // Clone files to avoid modifying the original
    const result = [...files];

    // Process each file
    for (const file of result) {
      // Check if this is an env file
      const isEnvFile = this.isEnvFile(file.filePath, effectiveConfig);

      // Handle env files specially if configured
      if (isEnvFile && effectiveConfig.scanEnvFiles) {
        if (effectiveConfig.envFilesKeysOnly) {
          // Replace env file content with keys only
          file.content = this.extractEnvFileKeys(file.content);

          // Add metadata about this transformation
          if (!file.meta) {
            file.meta = {};
          }

          file.meta.securityTransformed = true;
          file.meta.securityTransformedReason = 'Env file values redacted, only keys included';

          // Skip further scanning for this file
          continue;
        }
      }

      // Scan file content for sensitive patterns
      const issues = this.scanContent(file.filePath, file.content, patterns);

      if (issues.length > 0) {
        // Add security warnings to file metadata
        if (!file.meta) {
          file.meta = {};
        }

        if (!file.meta.securityIssues) {
          file.meta.securityIssues = [];
        }

        // Add each issue to metadata
        for (const issue of issues) {
          file.meta.securityIssues.push({
            scanner: this.id,
            severity: issue.severity,
            description: `Found potential ${issue.name}`,
            details: `Line ${issue.lineNumber}: ${issue.description}`,
            line: issue.lineNumber
          });
        }
      }
    }

    return result;
  }

  /**
   * Generate a security report for files
   * @param files Files to scan
   * @param config Configuration for the scanner
   * @returns Security report
   */
  async generateSecurityReport(files: CollectedFile[], config?: SensitiveDataScannerConfig): Promise<SecurityReport> {
    const effectiveConfig = this.getEffectiveConfig(config);

    // Combine built-in and custom patterns
    const patterns = [
      ...this.builtInPatterns,
      ...(effectiveConfig.customPatterns || [])
    ];

    const issues: SecurityIssue[] = [];
    let filesWithIssues = 0;

    // Process each file
    for (const file of files) {
      // Check if this is an env file
      const isEnvFile = this.isEnvFile(file.filePath, effectiveConfig);

      // Handle env files specially if configured
      if (isEnvFile && effectiveConfig.scanEnvFiles) {
        if (effectiveConfig.envFilesKeysOnly) {
          // Add a note about env file transformation
          issues.push({
            filePath: file.filePath,
            severity: SecurityIssueSeverity.INFO,
            description: 'Env file values redacted, only keys included',
            remediation: 'No action needed, this is a security precaution'
          });

          filesWithIssues++;
          continue;
        }
      }

      // Scan file content for sensitive patterns
      const fileIssues = this.scanContent(file.filePath, file.content, patterns);

      if (fileIssues.length > 0) {
        // Convert to SecurityIssue format
        for (const issue of fileIssues) {
          issues.push({
            filePath: file.filePath,
            lineNumber: issue.lineNumber,
            severity: issue.severity,
            description: `Found potential ${issue.name}`,
            content: effectiveConfig.redactSensitiveData
              ? this.redactSensitiveData(issue.content)
              : issue.content
          });
        }

        filesWithIssues++;
      }
    }

    // Count issues by severity
    const issuesBySeverity = issues.reduce((acc, issue) => {
      acc[issue.severity] = (acc[issue.severity] || 0) + 1;
      return acc;
    }, {} as Record<SecurityIssueSeverity, number>);

    return {
      scannerId: this.id,
      issues,
      summary: {
        totalFiles: files.length,
        filesWithIssues,
        issuesBySeverity
      }
    };
  }

  /**
   * Scan content for sensitive data patterns
   * @param filePath File path (for reporting)
   * @param content Content to scan
   * @param patterns Patterns to scan for
   * @returns Issues found
   */
  private scanContent(
    filePath: string,
    content: string,
    patterns: Array<{ name: string; pattern: string; severity: SecurityIssueSeverity }>
  ): Array<{
    name: string;
    severity: SecurityIssueSeverity;
    lineNumber: number;
    description: string;
    content: string;
  }> {
    const issues: Array<{
      name: string;
      severity: SecurityIssueSeverity;
      lineNumber: number;
      description: string;
      content: string;
    }> = [];

    // Split content into lines
    const lines = content.split('\n');

    // Check each line against each pattern
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      for (const { name, pattern, severity } of patterns) {
        try {
          const regex = new RegExp(pattern, 'g');
          const matches = line.matchAll(regex);

          for (const match of matches) {
            issues.push({
              name,
              severity,
              lineNumber: i + 1,
              description: `Found potential ${name}`,
              content: line
            });
          }
        } catch (error) {
          console.warn(`Error with pattern ${name}:`, error instanceof Error ? error.message : String(error));
        }
      }
    }

    return issues;
  }

  /**
   * Check if a file is an env file
   * @param filePath File path
   * @param config Scanner configuration
   * @returns Whether the file is an env file
   */
  private isEnvFile(filePath: string, config: SensitiveDataScannerConfig): boolean {
    const envFilePatterns = config.envFilePatterns || this.defaultEnvFilePatterns;

    // Normalize path to use forward slashes
    const normalizedPath = filePath.replace(/\\/g, '/');

    // Check against patterns
    for (const pattern of envFilePatterns) {
      if (this.matchesGlobPattern(normalizedPath, pattern)) {
        return true;
      }
    }

    // Also check common env file names
    const basename = path.basename(filePath).toLowerCase();
    if (basename === '.env' || basename.startsWith('.env.') || basename === 'credentials.json') {
      return true;
    }

    return false;
  }

  /**
   * Extract keys from env file content
   * @param content Env file content
   * @returns Content with only keys (values redacted)
   */
  private extractEnvFileKeys(content: string): string {
    const lines = content.split('\n');
    const result: string[] = [];

    for (const line of lines) {
      // Skip comments and empty lines
      if (line.trim().startsWith('#') || line.trim() === '') {
        result.push(line);
        continue;
      }

      // Extract key from KEY=VALUE format
      const match = line.match(/^([^=]+)=(.*)$/);
      if (match) {
        const key = match[1].trim();
        result.push(`${key}=<REDACTED>`);
      } else {
        // If not in KEY=VALUE format, keep the line as is
        result.push(line);
      }
    }

    return result.join('\n');
  }

  /**
   * Redact sensitive data from a string
   * @param text Text containing sensitive data
   * @returns Redacted text
   */
  private redactSensitiveData(text: string): string {
    // Simple redaction: replace middle part with asterisks
    // Keep first and last 4 characters if long enough
    if (text.length > 8) {
      const firstPart = text.substring(0, 4);
      const lastPart = text.substring(text.length - 4);
      const middleLength = text.length - 8;
      const redactedMiddle = '*'.repeat(Math.min(middleLength, 10));
      return `${firstPart}${redactedMiddle}${lastPart}`;
    }

    // For shorter strings, replace all with asterisks
    return '*'.repeat(text.length);
  }

  /**
   * Check if a path matches a glob pattern
   * @param path Path to check
   * @param pattern Glob pattern
   * @returns Whether the path matches the pattern
   */
  private matchesGlobPattern(path: string, pattern: string): boolean {
    // Convert glob pattern to regex
    const regexPattern = pattern
      .replace(/\./g, '\\.')
      .replace(/\*\*/g, '.*')
      .replace(/\*/g, '[^/]*')
      .replace(/\?/g, '.');

    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(path);
  }

  /**
   * Get effective configuration with defaults
   * @param config User-provided configuration
   * @returns Effective configuration with defaults applied
   */
  private getEffectiveConfig(config?: SensitiveDataScannerConfig): SensitiveDataScannerConfig {
    return {
      customPatterns: config?.customPatterns || [],
      redactSensitiveData: config?.redactSensitiveData !== false,
      scanEnvFiles: config?.scanEnvFiles !== false,
      envFilesKeysOnly: config?.envFilesKeysOnly !== false,
      envFilePatterns: config?.envFilePatterns || this.defaultEnvFilePatterns
    };
  }

  /**
   * Clean up resources
   */
  async cleanup(): Promise<void> {
    // Nothing to clean up
  }
}

// Export plugin instance
export default new SensitiveDataSecurityScanner();


[33m--- File: src/cli/studio/public/index.html (Size: 20868 bytes, 429 lines) ---[39m
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ContextR Studio</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
        }
        .sidebar {
            height: 100vh;
            background-color: #212529;
            color: white;
            padding: 20px 0;
            overflow-y: auto;
        }
        .file-tree {
            padding-left: 0;
        }
        .file-tree ul {
            padding-left: 20px;
        }
        .file-tree li {
            list-style-type: none;
            margin: 5px 0;
            cursor: pointer;
        }
        .file-tree .folder {
            color: #ffc107;
        }
        .file-tree .file {
            color: #ffffff;
        }
        .file-tree .selected {
            background-color: #0d6efd;
            border-radius: 3px;
            padding: 2px 5px;
        }
        .main-content {
            height: 100vh;
            overflow-y: auto;
            padding: 20px;
        }
        .nav-tabs {
            margin-bottom: 20px;
        }
        .config-panel, .search-panel, .preview-panel {
            background-color: white;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .context-item {
            background-color: #f1f1f1;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .context-item .actions {
            float: right;
        }
        .search-results {
            margin-top: 20px;
        }
        .match-highlight {
            background-color: #ffeb3b;
            font-weight: bold;
        }
        .logo {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
        }
        .logo i {
            margin-right: 10px;
            color: #0d6efd;
        }
        .drag-handle {
            cursor: move;
            padding: 5px;
        }
        .pattern-tag {
            display: inline-block;
            background-color: #e9ecef;
            padding: 5px 10px;
            border-radius: 15px;
            margin: 5px;
        }
        .pattern-tag .remove {
            margin-left: 5px;
            cursor: pointer;
        }
        .preview-code {
            background-color: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
            overflow-x: auto;
        }
        .status-bar {
            background-color: #343a40;
            color: white;
            padding: 5px 15px;
            position: fixed;
            bottom: 0;
            width: 100%;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar with file tree -->
            <div class="col-md-3 sidebar">
                <div class="logo">
                    <i class="bi bi-braces"></i> ContextR Studio
                </div>
                <div class="mb-3">
                    <div class="input-group">
                        <input type="text" id="path-input" class="form-control form-control-sm" placeholder="Path" value=".">
                        <button class="btn btn-outline-light btn-sm" id="browse-btn">Browse</button>
                    </div>
                </div>
                <div class="file-tree" id="file-tree">
                    <div class="d-flex justify-content-center">
                        <div class="spinner-border text-light" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main content area -->
            <div class="col-md-9 main-content">
                <ul class="nav nav-tabs" id="main-tabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="config-tab" data-bs-toggle="tab" data-bs-target="#config" type="button" role="tab" aria-controls="config" aria-selected="true">
                            <i class="bi bi-gear"></i> Configuration
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="search-tab" data-bs-toggle="tab" data-bs-target="#search" type="button" role="tab" aria-controls="search" aria-selected="false">
                            <i class="bi bi-search"></i> Search
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="preview-tab" data-bs-toggle="tab" data-bs-target="#preview" type="button" role="tab" aria-controls="preview" aria-selected="false">
                            <i class="bi bi-eye"></i> Preview
                        </button>
                    </li>
                </ul>

                <div class="tab-content" id="main-tabs-content">
                    <!-- Configuration Tab -->
                    <div class="tab-pane fade show active" id="config" role="tabpanel" aria-labelledby="config-tab">
                        <div class="config-panel">
                            <div class="row mb-4">
                                <div class="col-md-8">
                                    <h4>Context Configuration</h4>
                                </div>
                                <div class="col-md-4 text-end">
                                    <div class="btn-group">
                                        <button class="btn btn-outline-secondary dropdown-toggle" type="button" id="load-config-btn" data-bs-toggle="dropdown" aria-expanded="false">
                                            <i class="bi bi-folder-open"></i> Load
                                        </button>
                                        <ul class="dropdown-menu" id="config-list">
                                            <li><a class="dropdown-item" href="#">Loading...</a></li>
                                        </ul>
                                    </div>
                                    <button class="btn btn-outline-primary" id="save-config-btn">
                                        <i class="bi bi-save"></i> Save
                                    </button>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label for="context-name" class="form-label">Context Name</label>
                                <input type="text" class="form-control" id="context-name" placeholder="My Project Context" value="Project Context">
                            </div>

                            <div class="row mb-3">
                                <div class="col-md-6">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="show-contents" checked>
                                        <label class="form-check-label" for="show-contents">
                                            Show File Contents
                                        </label>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="show-meta" checked>
                                        <label class="form-check-label" for="show-meta">
                                            Show Metadata
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <div class="row mb-3">
                                <div class="col-md-6">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="use-regex">
                                        <label class="form-check-label" for="use-regex">
                                            Use Regex for Pattern Matching
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <h5 class="mt-4">Included Directories</h5>
                            <div id="include-dirs">
                                <!-- Directory items will be added here -->
                            </div>
                            <button class="btn btn-sm btn-outline-success mt-2" id="add-dir-btn">
                                <i class="bi bi-plus-circle"></i> Add Directory
                            </button>

                            <h5 class="mt-4">Included Files</h5>
                            <div id="include-files-container">
                                <div class="pattern-tags" id="include-files">
                                    <!-- File patterns will be added here -->
                                </div>
                                <div class="input-group mt-2">
                                    <input type="text" class="form-control" id="include-file-input" placeholder="Add file pattern (e.g., *.js, src/index.ts)">
                                    <button class="btn btn-outline-primary" id="add-include-file-btn">Add</button>
                                </div>
                            </div>

                            <h5 class="mt-4">Excluded Files</h5>
                            <div id="exclude-files-container">
                                <div class="pattern-tags" id="exclude-files">
                                    <!-- Exclude patterns will be added here -->
                                </div>
                                <div class="input-group mt-2">
                                    <input type="text" class="form-control" id="exclude-file-input" placeholder="Add exclude pattern (e.g., node_modules/**, *.test.js)">
                                    <button class="btn btn-outline-primary" id="add-exclude-file-btn">Add</button>
                                </div>
                            </div>

                            <div class="mt-4">
                                <button class="btn btn-primary" id="build-context-btn">
                                    <i class="bi bi-gear"></i> Build Context
                                </button>
                                <button class="btn btn-outline-secondary" id="reset-config-btn">
                                    <i class="bi bi-arrow-counterclockwise"></i> Reset
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Search Tab -->
                    <div class="tab-pane fade" id="search" role="tabpanel" aria-labelledby="search-tab">
                        <div class="search-panel">
                            <h4>Search in Files</h4>
                            <div class="mb-3">
                                <label for="search-pattern" class="form-label">Search Pattern</label>
                                <input type="text" class="form-control" id="search-pattern" placeholder="Enter search pattern">
                            </div>

                            <div class="row mb-3">
                                <div class="col-md-4">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="search-regex">
                                        <label class="form-check-label" for="search-regex">
                                            Use Regex
                                        </label>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="case-sensitive">
                                        <label class="form-check-label" for="case-sensitive">
                                            Case Sensitive
                                        </label>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="whole-word">
                                        <label class="form-check-label" for="whole-word">
                                            Whole Word
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label for="context-lines" class="form-label">Context Lines</label>
                                <input type="number" class="form-control" id="context-lines" min="0" max="10" value="2">
                            </div>

                            <button class="btn btn-primary" id="search-btn">
                                <i class="bi bi-search"></i> Search
                            </button>

                            <div class="search-results mt-4" id="search-results">
                                <!-- Search results will be displayed here -->
                            </div>
                        </div>
                    </div>

                    <!-- Preview Tab -->
                    <div class="tab-pane fade" id="preview" role="tabpanel" aria-labelledby="preview-tab">
                        <div class="preview-panel">
                            <h4>Context Preview</h4>
                            <div class="mb-3">
                                <select class="form-select" id="preview-format">
                                    <option value="console">Console Format</option>
                                    <option value="json">JSON Format</option>
                                </select>
                            </div>
                            <div class="preview-content" id="preview-content">
                                <div class="alert alert-info">
                                    Build context first to see the preview.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="row">
            <div class="col-md-4" id="status-message">Ready</div>
            <div class="col-md-4 text-center" id="status-files">Files: 0</div>
            <div class="col-md-4 text-end" id="status-version">ContextR v1.0.17</div>
        </div>
    </div>

    <!-- Modal for Directory Configuration -->
    <div class="modal fade" id="dir-config-modal" tabindex="-1" aria-labelledby="dir-config-modal-label" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="dir-config-modal-label">Directory Configuration</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="dir-path" class="form-label">Directory Path</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="dir-path" placeholder="./src">
                            <button class="btn btn-outline-secondary" id="browse-dir-btn">Browse</button>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="include-patterns" class="form-label">Include Patterns</label>
                        <div id="dir-include-patterns">
                            <div class="pattern-tags" id="dir-include-tags">
                                <!-- Include patterns will be added here -->
                            </div>
                            <div class="input-group mt-2">
                                <input type="text" class="form-control" id="dir-include-input" placeholder="Add pattern (e.g., *.js, **/*.ts)">
                                <button class="btn btn-outline-primary" id="add-dir-include-btn">Add</button>
                            </div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="exclude-patterns" class="form-label">Exclude Patterns</label>
                        <div id="dir-exclude-patterns">
                            <div class="pattern-tags" id="dir-exclude-tags">
                                <!-- Exclude patterns will be added here -->
                            </div>
                            <div class="input-group mt-2">
                                <input type="text" class="form-control" id="dir-exclude-input" placeholder="Add pattern (e.g., node_modules/**, *.test.js)">
                                <button class="btn btn-outline-primary" id="add-dir-exclude-btn">Add</button>
                            </div>
                        </div>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="dir-recursive" checked>
                        <label class="form-check-label" for="dir-recursive">
                            Recursive (include subdirectories)
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="dir-use-regex">
                        <label class="form-check-label" for="dir-use-regex">
                            Use Regex for Pattern Matching
                        </label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="save-dir-config-btn">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for Save Configuration -->
    <div class="modal fade" id="save-config-modal" tabindex="-1" aria-labelledby="save-config-modal-label" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="save-config-modal-label">Save Configuration</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="config-name" class="form-label">Configuration Name</label>
                        <input type="text" class="form-control" id="config-name" placeholder="my-project-config">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="confirm-save-config-btn">Save</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="main.js"></script>
</body>
</html>


[33m--- File: src/cli/studio/public/main.js (Size: 35855 bytes, 1086 lines) ---[39m
// ESM/CJS compatibility wrapper
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['exports'], factory);
  } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
    // CommonJS
    factory(exports);
  } else {
    // Browser globals
    factory((root.contextr = {}));
  }
}(typeof self !== 'undefined' ? self : this, function(exports) {
  // Main JavaScript for ContextR Studio UI

  // Global state
  let currentConfig = {
    name: "Project Context",
    showContents: true,
    showMeta: true,
    includeDirs: [],
    includeFiles: [],
    excludeFiles: [],
    useRegex: false
  };

  let currentContext = null;
  let currentDirIndex = -1;
  let selectedFiles = new Set();

  // DOM Elements
  function initializeUI() {
    const fileTree = document.getElementById('file-tree');
    const pathInput = document.getElementById('path-input');
    const browseBtn = document.getElementById('browse-btn');
    const includeDirsContainer = document.getElementById('include-dirs');
    const includeFilesContainer = document.getElementById('include-files');
    const excludeFilesContainer = document.getElementById('exclude-files');
    const addDirBtn = document.getElementById('add-dir-btn');
    const addIncludeFileBtn = document.getElementById('add-include-file-btn');
    const addExcludeFileBtn = document.getElementById('add-exclude-file-btn');
    const includeFileInput = document.getElementById('include-file-input');
    const excludeFileInput = document.getElementById('exclude-file-input');
    const buildContextBtn = document.getElementById('build-context-btn');
    const resetConfigBtn = document.getElementById('reset-config-btn');
    const contextNameInput = document.getElementById('context-name');
    const showContentsCheckbox = document.getElementById('show-contents');
    const showMetaCheckbox = document.getElementById('show-meta');
    const useRegexCheckbox = document.getElementById('use-regex');
    const previewContent = document.getElementById('preview-content');
    const previewFormat = document.getElementById('preview-format');
    const searchBtn = document.getElementById('search-btn');
    const searchPattern = document.getElementById('search-pattern');
    const searchRegex = document.getElementById('search-regex');
    const caseSensitive = document.getElementById('case-sensitive');
    const wholeWord = document.getElementById('whole-word');
    const contextLines = document.getElementById('context-lines');
    const searchResults = document.getElementById('search-results');
    const statusMessage = document.getElementById('status-message');
    const statusFiles = document.getElementById('status-files');
    const saveConfigBtn = document.getElementById('save-config-btn');
    const loadConfigBtn = document.getElementById('load-config-btn');
    const configList = document.getElementById('config-list');

    // Initialize UI
    document.addEventListener('DOMContentLoaded', () => {
      // Load file tree
      loadFileTree(pathInput.value);
      
      // Initialize sortable for directory items
      if (typeof Sortable !== 'undefined') {
        new Sortable(includeDirsContainer, {
          animation: 150,
          handle: '.drag-handle',
          ghostClass: 'sortable-ghost'
        });
      }
      
      // Load saved configurations
      loadConfigList();
      
      // Set up event listeners
      setupEventListeners();
      
      // Update status bar with version
      const versionElement = document.getElementById('status-version');
      if (versionElement) {
        versionElement.textContent = `ContextR v${getPackageVersion()}`;
      }
    });

    // Helper function to get package version
    function getPackageVersion() {
      // This would normally come from the package.json, but we'll hardcode it for now
      return "1.0.17";
    }

    // Set up all event listeners
    function setupEventListeners() {
      // Browse button
      if (browseBtn) {
        browseBtn.addEventListener('click', () => {
          loadFileTree(pathInput.value);
        });
      }
      
      // Path input enter key
      if (pathInput) {
        pathInput.addEventListener('keyup', (e) => {
          if (e.key === 'Enter') {
            loadFileTree(pathInput.value);
          }
        });
      }
      
      // Add directory button
      if (addDirBtn) {
        addDirBtn.addEventListener('click', () => {
          showDirectoryModal();
        });
      }
      
      // Add include file button
      if (addIncludeFileBtn) {
        addIncludeFileBtn.addEventListener('click', () => {
          addIncludeFile();
        });
      }
      
      // Include file input enter key
      if (includeFileInput) {
        includeFileInput.addEventListener('keyup', (e) => {
          if (e.key === 'Enter') {
            addIncludeFile();
          }
        });
      }
      
      // Add exclude file button
      if (addExcludeFileBtn) {
        addExcludeFileBtn.addEventListener('click', () => {
          addExcludeFile();
        });
      }
      
      // Exclude file input enter key
      if (excludeFileInput) {
        excludeFileInput.addEventListener('keyup', (e) => {
          if (e.key === 'Enter') {
            addExcludeFile();
          }
        });
      }
      
      // Build context button
      if (buildContextBtn) {
        buildContextBtn.addEventListener('click', () => {
          buildContext();
        });
      }
      
      // Reset config button
      if (resetConfigBtn) {
        resetConfigBtn.addEventListener('click', () => {
          resetConfig();
        });
      }
      
      // Preview format change
      if (previewFormat) {
        previewFormat.addEventListener('change', () => {
          if (currentContext) {
            updatePreview();
          }
        });
      }
      
      // Search button
      if (searchBtn) {
        searchBtn.addEventListener('click', () => {
          performSearch();
        });
      }
      
      // Save config button
      if (saveConfigBtn) {
        saveConfigBtn.addEventListener('click', () => {
          showSaveConfigModal();
        });
      }
      
      // Directory modal save button
      const saveDirConfigBtn = document.getElementById('save-dir-config-btn');
      if (saveDirConfigBtn) {
        saveDirConfigBtn.addEventListener('click', () => {
          saveDirConfig();
        });
      }
      
      // Config save modal confirm button
      const confirmSaveConfigBtn = document.getElementById('confirm-save-config-btn');
      if (confirmSaveConfigBtn) {
        confirmSaveConfigBtn.addEventListener('click', () => {
          saveConfig();
        });
      }
      
      // Form inputs for config
      if (contextNameInput) {
        contextNameInput.addEventListener('change', () => {
          currentConfig.name = contextNameInput.value;
        });
      }
      
      if (showContentsCheckbox) {
        showContentsCheckbox.addEventListener('change', () => {
          currentConfig.showContents = showContentsCheckbox.checked;
        });
      }
      
      if (showMetaCheckbox) {
        showMetaCheckbox.addEventListener('change', () => {
          currentConfig.showMeta = showMetaCheckbox.checked;
        });
      }
      
      if (useRegexCheckbox) {
        useRegexCheckbox.addEventListener('change', () => {
          currentConfig.useRegex = useRegexCheckbox.checked;
        });
      }
    }

    // Load file tree from server
    async function loadFileTree(dirPath) {
      try {
        updateStatus(`Loading files from ${dirPath}...`);
        if (fileTree) {
          fileTree.innerHTML = `
            <div class="d-flex justify-content-center">
              <div class="spinner-border text-light" role="status">
                <span class="visually-hidden">Loading...</span>
              </div>
            </div>
          `;
        }
        
        const response = await fetch(`/api/files?path=${encodeURIComponent(dirPath)}`);
        if (!response.ok) {
          throw new Error(`Failed to load files: ${response.statusText}`);
        }
        
        const data = await response.json();
        if (fileTree) {
          renderFileTree(data, fileTree);
        }
        updateStatus('Files loaded successfully');
        if (statusFiles) {
          statusFiles.textContent = `Files: ${data.length}`;
        }
      } catch (error) {
        if (fileTree) {
          fileTree.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
        }
        updateStatus(`Error: ${error.message}`, true);
      }
    }

    // Render file tree
    function renderFileTree(files, container) {
      container.innerHTML = '';
      const ul = document.createElement('ul');
      ul.className = 'file-tree';
      
      // Sort directories first, then files
      files.sort((a, b) => {
        if (a.isDirectory && !b.isDirectory) return -1;
        if (!a.isDirectory && b.isDirectory) return 1;
        return a.name.localeCompare(b.name);
      });
      
      files.forEach(file => {
        const li = document.createElement('li');
        const icon = file.isDirectory ? 'bi-folder-fill folder' : 'bi-file-text file';
        
        li.innerHTML = `<i class="bi ${icon}"></i> ${file.name}`;
        li.dataset.path = file.path;
        li.dataset.isDirectory = file.isDirectory;
        
        if (file.isDirectory) {
          li.addEventListener('click', (e) => {
            e.stopPropagation();
            if (e.ctrlKey || e.metaKey) {
              // Add directory to config
              addDirectoryToConfig(file.path);
            } else {
              // Navigate to directory
              if (pathInput) {
                pathInput.value = file.path;
                loadFileTree(file.path);
              }
            }
          });
        } else {
          li.addEventListener('click', (e) => {
            e.stopPropagation();
            if (e.ctrlKey || e.metaKey) {
              // Toggle file selection
              if (selectedFiles.has(file.path)) {
                selectedFiles.delete(file.path);
                li.classList.remove('selected');
              } else {
                selectedFiles.add(file.path);
                li.classList.add('selected');
              }
            } else {
              // Add file to include files
              addFileToInclude(file.path);
            }
          });
        }
        
        ul.appendChild(li);
      });
      
      container.appendChild(ul);
    }

    // Add directory to config
    function addDirectoryToConfig(dirPath) {
      const dirConfig = {
        path: dirPath,
        include: ['**/*'],
        exclude: [],
        recursive: true,
        useRegex: currentConfig.useRegex
      };
      
      currentConfig.includeDirs.push(dirConfig);
      renderIncludeDirs();
      updateStatus(`Added directory: ${dirPath}`);
    }

    // Render include directories
    function renderIncludeDirs() {
      if (!includeDirsContainer) return;
      
      includeDirsContainer.innerHTML = '';
      
      currentConfig.includeDirs.forEach((dirConfig, index) => {
        const dirItem = document.createElement('div');
        dirItem.className = 'context-item';
        dirItem.dataset.index = index;
        
        dirItem.innerHTML = `
          <div class="drag-handle"><i class="bi bi-grip-vertical"></i></div>
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <strong>${dirConfig.path}</strong>
              <div class="small text-muted">
                Include: ${dirConfig.include.join(', ')}
                ${dirConfig.exclude.length > 0 ? `<br>Exclude: ${dirConfig.exclude.join(', ')}` : ''}
                <br>Recursive: ${dirConfig.recursive ? 'Yes' : 'No'}, 
                Regex: ${dirConfig.useRegex ? 'Yes' : 'No'}
              </div>
            </div>
            <div class="actions">
              <button class="btn btn-sm btn-outline-primary edit-dir-btn" data-index="${index}">
                <i class="bi bi-pencil"></i>
              </button>
              <button class="btn btn-sm btn-outline-danger remove-dir-btn" data-index="${index}">
                <i class="bi bi-trash"></i>
              </button>
            </div>
          </div>
        `;
        
        includeDirsContainer.appendChild(dirItem);
        
        // Add event listeners
        dirItem.querySelector('.edit-dir-btn').addEventListener('click', () => {
          editDirectory(index);
        });
        
        dirItem.querySelector('.remove-dir-btn').addEventListener('click', () => {
          removeDirectory(index);
        });
      });
    }

    // Show directory configuration modal
    function showDirectoryModal(index = -1) {
      currentDirIndex = index;
      
      // Check if Bootstrap is available
      if (typeof bootstrap === 'undefined') {
        console.error('Bootstrap is not available');
        return;
      }
      
      const modalElement = document.getElementById('dir-config-modal');
      if (!modalElement) return;
      
      const modal = new bootstrap.Modal(modalElement);
      const dirPath = document.getElementById('dir-path');
      const dirRecursive = document.getElementById('dir-recursive');
      const dirUseRegex = document.getElementById('dir-use-regex');
      const dirIncludeTags = document.getElementById('dir-include-tags');
      const dirExcludeTags = document.getElementById('dir-exclude-tags');
      
      if (!dirPath || !dirRecursive || !dirUseRegex || !dirIncludeTags || !dirExcludeTags) {
        console.error('Modal elements not found');
        return;
      }
      
      // Clear previous values
      dirPath.value = '';
      dirRecursive.checked = true;
      dirUseRegex.checked = currentConfig.useRegex;
      dirIncludeTags.innerHTML = '';
      dirExcludeTags.innerHTML = '';
      
      // If editing existing directory
      if (index >= 0 && index < currentConfig.includeDirs.length) {
        const dirConfig = currentConfig.includeDirs[index];
        dirPath.value = dirConfig.path;
        dirRecursive.checked = dirConfig.recursive;
        dirUseRegex.checked = dirConfig.useRegex || false;
        
        // Render include patterns
        dirConfig.include.forEach(pattern => {
          addPatternTag(pattern, dirIncludeTags, 'dir-include');
        });
        
        // Render exclude patterns
        if (dirConfig.exclude) {
          dirConfig.exclude.forEach(pattern => {
            addPatternTag(pattern, dirExcludeTags, 'dir-exclude');
          });
        }
      }
      
      modal.show();
      
      // Set up event listeners for the modal
      const addDirIncludeBtn = document.getElementById('add-dir-include-btn');
      if (addDirIncludeBtn) {
        addDirIncludeBtn.onclick = () => {
          const input = document.getElementById('dir-include-input');
          if (input && input.value.trim()) {
            addPatternTag(input.value.trim(), dirIncludeTags, 'dir-include');
            input.value = '';
          }
        };
      }
      
      const addDirExcludeBtn = document.getElementById('add-dir-exclude-btn');
      if (addDirExcludeBtn) {
        addDirExcludeBtn.onclick = () => {
          const input = document.getElementById('dir-exclude-input');
          if (input && input.value.trim()) {
            addPatternTag(input.value.trim(), dirExcludeTags, 'dir-exclude');
            input.value = '';
          }
        };
      }
      
      const dirIncludeInput = document.getElementById('dir-include-input');
      if (dirIncludeInput) {
        dirIncludeInput.onkeyup = (e) => {
          if (e.key === 'Enter' && addDirIncludeBtn) {
            addDirIncludeBtn.click();
          }
        };
      }
      
      const dirExcludeInput = document.getElementById('dir-exclude-input');
      if (dirExcludeInput) {
        dirExcludeInput.onkeyup = (e) => {
          if (e.key === 'Enter' && addDirExcludeBtn) {
            addDirExcludeBtn.click();
          }
        };
      }
      
      const browseDirBtn = document.getElementById('browse-dir-btn');
      if (browseDirBtn && dirPath && pathInput) {
        browseDirBtn.onclick = () => {
          // This would normally open a directory browser, but we'll use the current path
          dirPath.value = pathInput.value;
        };
      }
    }

    // Add pattern tag to container
    function addPatternTag(pattern, container, prefix) {
      const tag = document.createElement('span');
      tag.className = 'pattern-tag';
      tag.innerHTML = `
        ${pattern}
        <span class="remove" data-pattern="${pattern}">Ã—</span>
      `;
      
      container.appendChild(tag);
      
      // Add event listener to remove button
      tag.querySelector('.remove').addEventListener('click', (e) => {
        e.target.parentElement.remove();
      });
    }

    // Save directory configuration
    function saveDirConfig() {
      const dirPathElement = document.getElementById('dir-path');
      if (!dirPathElement) return;
      
      const dirPath = dirPathElement.value.trim();
      if (!dirPath) {
        alert('Directory path is required');
        return;
      }
      
      // Get include patterns
      const includePatterns = [];
      document.querySelectorAll('#dir-include-tags .pattern-tag').forEach(tag => {
        const pattern = tag.textContent.trim().replace('Ã—', '');
        includePatterns.push(pattern);
      });
      
      if (includePatterns.length === 0) {
        includePatterns.push('**/*'); // Default pattern
      }
      
      // Get exclude patterns
      const excludePatterns = [];
      document.querySelectorAll('#dir-exclude-tags .pattern-tag').forEach(tag => {
        const pattern = tag.textContent.trim().replace('Ã—', '');
        excludePatterns.push(pattern);
      });
      
      const dirRecursiveElement = document.getElementById('dir-recursive');
      const dirUseRegexElement = document.getElementById('dir-use-regex');
      
      const dirConfig = {
        path: dirPath,
        include: includePatterns,
        exclude: excludePatterns,
        recursive: dirRecursiveElement ? dirRecursiveElement.checked : true,
        useRegex: dirUseRegexElement ? dirUseRegexElement.checked : false
      };
      
      if (currentDirIndex >= 0) {
        // Update existing directory
        currentConfig.includeDirs[currentDirIndex] = dirConfig;
      } else {
        // Add new directory
        currentConfig.includeDirs.push(dirConfig);
      }
      
      renderIncludeDirs();
      
      // Close modal if Bootstrap is available
      if (typeof bootstrap !== 'undefined') {
        const modalElement = document.getElementById('dir-config-modal');
        if (modalElement) {
          const modal = bootstrap.Modal.getInstance(modalElement);
          if (modal) {
            modal.hide();
          }
        }
      }
      
      updateStatus(`${currentDirIndex >= 0 ? 'Updated' : 'Added'} directory: ${dirPath}`);
    }

    // Edit directory
    function editDirectory(index) {
      showDirectoryModal(index);
    }

    // Remove directory
    function removeDirectory(index) {
      if (confirm('Are you sure you want to remove this directory?')) {
        currentConfig.includeDirs.splice(index, 1);
        renderIncludeDirs();
        updateStatus('Directory removed');
      }
    }

    // Add file to include files
    function addFileToInclude(filePath) {
      if (!currentConfig.includeFiles.includes(filePath)) {
        currentConfig.includeFiles.push(filePath);
        renderIncludeFiles();
        updateStatus(`Added file: ${filePath}`);
      }
    }

    // Add include file from input
    function addIncludeFile() {
      if (!includeFileInput) return;
      
      const pattern = includeFileInput.value.trim();
      if (pattern && !currentConfig.includeFiles.includes(pattern)) {
        currentConfig.includeFiles.push(pattern);
        renderIncludeFiles();
        includeFileInput.value = '';
        updateStatus(`Added include pattern: ${pattern}`);
      }
    }

    // Add exclude file from input
    function addExcludeFile() {
      if (!excludeFileInput) return;
      
      const pattern = excludeFileInput.value.trim();
      if (pattern && !currentConfig.excludeFiles.includes(pattern)) {
        currentConfig.excludeFiles.push(pattern);
        renderExcludeFiles();
        excludeFileInput.value = '';
        updateStatus(`Added exclude pattern: ${pattern}`);
      }
    }

    // Render include files
    function renderIncludeFiles() {
      if (!includeFilesContainer) return;
      
      includeFilesContainer.innerHTML = '';
      
      currentConfig.includeFiles.forEach(pattern => {
        const tag = document.createElement('span');
        tag.className = 'pattern-tag';
        tag.innerHTML = `
          ${pattern}
          <span class="remove" data-pattern="${pattern}">Ã—</span>
        `;
        
        includeFilesContainer.appendChild(tag);
        
        // Add event listener to remove button
        tag.querySelector('.remove').addEventListener('click', (e) => {
          const pattern = e.target.dataset.pattern;
          currentConfig.includeFiles = currentConfig.includeFiles.filter(p => p !== pattern);
          renderIncludeFiles();
          updateStatus(`Removed include pattern: ${pattern}`);
        });
      });
    }

    // Render exclude files
    function renderExcludeFiles() {
      if (!excludeFilesContainer) return;
      
      excludeFilesContainer.innerHTML = '';
      
      currentConfig.excludeFiles.forEach(pattern => {
        const tag = document.createElement('span');
        tag.className = 'pattern-tag';
        tag.innerHTML = `
          ${pattern}
          <span class="remove" data-pattern="${pattern}">Ã—</span>
        `;
        
        excludeFilesContainer.appendChild(tag);
        
        // Add event listener to remove button
        tag.querySelector('.remove').addEventListener('click', (e) => {
          const pattern = e.target.dataset.pattern;
          currentConfig.excludeFiles = currentConfig.excludeFiles.filter(p => p !== pattern);
          renderExcludeFiles();
          updateStatus(`Removed exclude pattern: ${pattern}`);
        });
      });
    }

    // Build context
    async function buildContext() {
      try {
        updateStatus('Building context...');
        
        // Update config from form inputs
        if (contextNameInput) {
          currentConfig.name = contextNameInput.value;
        }
        
        if (showContentsCheckbox) {
          currentConfig.showContents = showContentsCheckbox.checked;
        }
        
        if (showMetaCheckbox) {
          currentConfig.showMeta = showMetaCheckbox.checked;
        }
        
        if (useRegexCheckbox) {
          currentConfig.useRegex = useRegexCheckbox.checked;
        }
        
        // Check if we have any directories or files
        if (currentConfig.includeDirs.length === 0 && currentConfig.includeFiles.length === 0) {
          alert('Please add at least one directory or file pattern');
          updateStatus('Error: No directories or files specified', true);
          return;
        }
        
        // Build context
        const format = previewFormat ? previewFormat.value : 'console';
        
        const response = await fetch('/api/context/build', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            config: currentConfig,
            format
          })
        });
        
        if (!response.ok) {
          throw new Error(`Failed to build context: ${response.statusText}`);
        }
        
        const data = await response.json();
        currentContext = data;
        
        // Update preview
        updatePreview();
        
        // Update status
        updateStatus(`Context built successfully: ${data.totalFiles} files`);
        if (statusFiles) {
          statusFiles.textContent = `Files: ${data.totalFiles}`;
        }
        
        // Switch to preview tab
        if (typeof bootstrap !== 'undefined') {
          const previewTab = document.getElementById('preview-tab');
          if (previewTab) {
            const tab = new bootstrap.Tab(previewTab);
            tab.show();
          }
        }
      } catch (error) {
        updateStatus(`Error building context: ${error.message}`, true);
        if (previewContent) {
          previewContent.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
        }
      }
    }

    // Update preview
    function updatePreview() {
      if (!previewContent || !currentContext) return;
      
      const format = previewFormat ? previewFormat.value : 'console';
      
      if (format === 'json') {
        // JSON format
        const jsonOutput = JSON.stringify(currentContext.context || currentContext, null, 2);
        previewContent.innerHTML = `<pre class="preview-code">${escapeHtml(jsonOutput)}</pre>`;
      } else {
        // Console format
        previewContent.innerHTML = `<pre class="preview-code">${escapeHtml(currentContext.output || '')}</pre>`;
      }
    }

    // Perform search
    async function performSearch() {
      try {
        if (!searchPattern || !searchResults) return;
        
        const pattern = searchPattern.value.trim();
        if (!pattern) {
          alert('Please enter a search pattern');
          return;
        }
        
        updateStatus('Searching...');
        
        // Build search options
        const searchOptions = {
          pattern,
          isRegex: searchRegex ? searchRegex.checked : false,
          caseSensitive: caseSensitive ? caseSensitive.checked : false,
          wholeWord: wholeWord ? wholeWord.checked : false,
          contextLines: contextLines ? parseInt(contextLines.value, 10) : 2
        };
        
        // Perform search
        const response = await fetch('/api/search', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            config: currentConfig,
            searchOptions
          })
        });
        
        if (!response.ok) {
          throw new Error(`Failed to search: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Display results
        if (data.results.length === 0) {
          searchResults.innerHTML = `<div class="alert alert-warning">No matches found</div>`;
          updateStatus('Search completed: No matches found');
          return;
        }
        
        // Format results
        let resultsHtml = `
          <div class="alert alert-success">
            Found ${data.totalMatches} matches in ${data.matchedFiles} files (searched ${data.totalFiles} files)
          </div>
          <div class="list-group">
        `;
        
        data.results.forEach(result => {
          resultsHtml += `
            <div class="list-group-item">
              <div class="d-flex justify-content-between align-items-center">
                <h6 class="mb-1">${result.filePath}</h6>
                <span class="badge bg-primary rounded-pill">${result.matchCount} matches</span>
              </div>
              <pre class="mt-2 preview-code">${formatSearchResult(result)}</pre>
            </div>
          `;
        });
        
        resultsHtml += `</div>`;
        searchResults.innerHTML = resultsHtml;
        
        updateStatus(`Search completed: Found ${data.totalMatches} matches in ${data.matchedFiles} files`);
      } catch (error) {
        updateStatus(`Error searching: ${error.message}`, true);
        searchResults.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
      }
    }

    // Format search result
    function formatSearchResult(result) {
      let output = '';
      
      if (result.matches && result.matches.length > 0) {
        result.matches.forEach(match => {
          // Add line number
          output += `<span class="text-muted">${match.lineNumber}:</span> `;
          
          // Add content with highlighted match
          if (match.content) {
            output += escapeHtml(match.content);
          } else if (match.before || match.match || match.after) {
            output += escapeHtml(match.before || '');
            output += `<span class="match-highlight">${escapeHtml(match.match || '')}</span>`;
            output += escapeHtml(match.after || '');
          }
          
          output += '\n';
        });
      }
      
      return output;
    }

    // Reset config
    function resetConfig() {
      if (confirm('Are you sure you want to reset the configuration?')) {
        currentConfig = {
          name: "Project Context",
          showContents: true,
          showMeta: true,
          includeDirs: [],
          includeFiles: [],
          excludeFiles: [],
          useRegex: false
        };
        
        // Update UI
        if (contextNameInput) contextNameInput.value = currentConfig.name;
        if (showContentsCheckbox) showContentsCheckbox.checked = currentConfig.showContents;
        if (showMetaCheckbox) showMetaCheckbox.checked = currentConfig.showMeta;
        if (useRegexCheckbox) useRegexCheckbox.checked = currentConfig.useRegex;
        
        renderIncludeDirs();
        renderIncludeFiles();
        renderExcludeFiles();
        
        updateStatus('Configuration reset');
      }
    }

    // Show save config modal
    function showSaveConfigModal() {
      // Check if Bootstrap is available
      if (typeof bootstrap === 'undefined') {
        console.error('Bootstrap is not available');
        return;
      }
      
      const modalElement = document.getElementById('save-config-modal');
      if (!modalElement) return;
      
      const modal = new bootstrap.Modal(modalElement);
      const configNameInput = document.getElementById('config-name');
      const globalConfigCheckbox = document.getElementById('global-config');
      
      if (configNameInput) {
        configNameInput.value = currentConfig.name.replace(/\s+/g, '-').toLowerCase();
      }
      
      if (globalConfigCheckbox) {
        globalConfigCheckbox.checked = false;
      }
      
      modal.show();
    }

    // Save config
    async function saveConfig() {
      try {
        const configNameInput = document.getElementById('config-name');
        const globalConfigCheckbox = document.getElementById('global-config');
        
        if (!configNameInput) return;
        
        const name = configNameInput.value.trim();
        if (!name) {
          alert('Please enter a configuration name');
          return;
        }
        
        updateStatus('Saving configuration...');
        
        const response = await fetch('/api/config/save', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name,
            config: currentConfig,
            global: globalConfigCheckbox ? globalConfigCheckbox.checked : false
          })
        });
        
        if (!response.ok) {
          throw new Error(`Failed to save configuration: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Close modal if Bootstrap is available
        if (typeof bootstrap !== 'undefined') {
          const modalElement = document.getElementById('save-config-modal');
          if (modalElement) {
            const modal = bootstrap.Modal.getInstance(modalElement);
            if (modal) {
              modal.hide();
            }
          }
        }
        
        updateStatus(`Configuration saved: ${name}`);
        
        // Reload config list
        loadConfigList();
      } catch (error) {
        updateStatus(`Error saving configuration: ${error.message}`, true);
      }
    }

    // Load config list
    async function loadConfigList() {
      try {
        if (!configList) return;
        
        updateStatus('Loading configurations...');
        
        const response = await fetch('/api/config/list');
        if (!response.ok) {
          throw new Error(`Failed to load configurations: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (!data.configs || data.configs.length === 0) {
          configList.innerHTML = `<li><a class="dropdown-item disabled" href="#">No saved configurations</a></li>`;
          updateStatus('No saved configurations found');
          return;
        }
        
        configList.innerHTML = '';
        data.configs.forEach(config => {
          const li = document.createElement('li');
          li.innerHTML = `
            <a class="dropdown-item" href="#" data-name="${config.name}" data-global="${config.isGlobal}">
              ${config.name} ${config.isGlobal ? '(global)' : ''}
            </a>
          `;
          
          li.querySelector('a').addEventListener('click', (e) => {
            e.preventDefault();
            loadConfig(config.name, config.isGlobal);
          });
          
          configList.appendChild(li);
        });
        
        updateStatus(`Loaded ${data.configs.length} configurations`);
      } catch (error) {
        updateStatus(`Error loading configurations: ${error.message}`, true);
        if (configList) {
          configList.innerHTML = `<li><a class="dropdown-item disabled" href="#">Error: ${error.message}</a></li>`;
        }
      }
    }

    // Load config
    async function loadConfig(name, isGlobal) {
      try {
        updateStatus(`Loading configuration: ${name}...`);
        
        const response = await fetch(`/api/config/load?name=${encodeURIComponent(name)}&global=${isGlobal}`);
        if (!response.ok) {
          throw new Error(`Failed to load configuration: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Update current config
        currentConfig = data.config;
        
        // Update UI
        if (contextNameInput) contextNameInput.value = currentConfig.name || 'Project Context';
        if (showContentsCheckbox) showContentsCheckbox.checked = currentConfig.showContents !== false;
        if (showMetaCheckbox) showMetaCheckbox.checked = currentConfig.showMeta !== false;
        if (useRegexCheckbox) useRegexCheckbox.checked = currentConfig.useRegex === true;
        
        renderIncludeDirs();
        renderIncludeFiles();
        renderExcludeFiles();
        
        updateStatus(`Configuration loaded: ${name}`);
      } catch (error) {
        updateStatus(`Error loading configuration: ${error.message}`, true);
      }
    }

    // Update status
    function updateStatus(message, isError = false) {
      if (statusMessage) {
        statusMessage.textContent = message;
        statusMessage.className = isError ? 'col-md-4 text-danger' : 'col-md-4';
      }
      console.log(isError ? `ERROR: ${message}` : message);
    }

    // Helper function to escape HTML
    function escapeHtml(text) {
      if (!text) return '';
      
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Return public API
    return {
      loadFileTree,
      buildContext,
      performSearch,
      resetConfig,
      saveConfig,
      loadConfig
    };
  }

  // Export public API
  exports.initializeUI = initializeUI;
}));


[1m[34m=== Summary ===[39m[22m

[1m[35mIncluded Files:[39m[22m
  [36msrc/FileContextBuilder.ts[39m - [32m2642 bytes[39m, [32m93 lines[39m
  [36msrc/index.ts[39m - [32m550 bytes[39m, [32m10 lines[39m
  [36msrc/cli/index.ts[39m - [32m16694 bytes[39m, [32m454 lines[39m
  [36msrc/collector/FileCollector.ts[39m - [32m7441 bytes[39m, [32m207 lines[39m
  [36msrc/collector/FileContentSearch.ts[39m - [32m9747 bytes[39m, [32m300 lines[39m
  [36msrc/collector/ListOnlySupport.ts[39m - [32m4380 bytes[39m, [32m135 lines[39m
  [36msrc/collector/RegexPatternMatcher.ts[39m - [32m8420 bytes[39m, [32m258 lines[39m
  [36msrc/collector/WhitelistBlacklist.ts[39m - [32m6797 bytes[39m, [32m215 lines[39m
  [36msrc/plugins/PluginCLI.ts[39m - [32m7830 bytes[39m, [32m246 lines[39m
  [36msrc/plugins/PluginEnabledFileContextBuilder.ts[39m - [32m6486 bytes[39m, [32m234 lines[39m
  [36msrc/plugins/PluginManager.ts[39m - [32m12826 bytes[39m, [32m492 lines[39m
  [36msrc/renderers/ConsoleRenderer.ts[39m - [32m3907 bytes[39m, [32m112 lines[39m
  [36msrc/renderers/JsonRenderer.ts[39m - [32m1627 bytes[39m, [32m61 lines[39m
  [36msrc/renderers/Renderer.ts[39m - [32m147 bytes[39m, [32m6 lines[39m
  [36msrc/security/GitIgnoreIntegration.ts[39m - [32m8079 bytes[39m, [32m262 lines[39m
  [36msrc/tree/TreeCLI.ts[39m - [32m8377 bytes[39m, [32m227 lines[39m
  [36msrc/tree/TreeView.ts[39m - [32m12184 bytes[39m, [32m472 lines[39m
  [36msrc/cli/studio/index.ts[39m - [32m10240 bytes[39m, [32m334 lines[39m
  [36msrc/plugins/output-renderers/HTMLRenderer.ts[39m - [32m18315 bytes[39m, [32m730 lines[39m
  [36msrc/plugins/output-renderers/MarkdownRenderer.ts[39m - [32m11125 bytes[39m, [32m399 lines[39m
  [36msrc/plugins/llm-reviewers/BaseLLMReviewer.ts[39m - [32m13503 bytes[39m, [32m440 lines[39m
  [36msrc/plugins/llm-reviewers/LocalLLMReviewer.ts[39m - [32m12236 bytes[39m, [32m428 lines[39m
  [36msrc/types/chalk.d.ts[39m - [32m900 bytes[39m, [32m36 lines[39m
  [36msrc/types/express.d.ts[39m - [32m785 bytes[39m, [32m28 lines[39m
  [36msrc/types/fast-glob.d.ts[39m - [32m469 bytes[39m, [32m18 lines[39m
  [36msrc/types/index.ts[39m - [32m4753 bytes[39m, [32m181 lines[39m
  [36msrc/types/other-modules.d.ts[39m - [32m871 bytes[39m, [32m32 lines[39m
  [36msrc/plugins/security-scanners/GitIgnoreSecurityScanner.ts[39m - [32m12244 bytes[39m, [32m409 lines[39m
  [36msrc/plugins/security-scanners/SensitiveDataSecurityScanner.ts[39m - [32m12916 bytes[39m, [32m440 lines[39m
  [36msrc/cli/studio/public/index.html[39m - [32m20868 bytes[39m, [32m429 lines[39m
  [36msrc/cli/studio/public/main.js[39m - [32m35855 bytes[39m, [32m1086 lines[39m

[1m[35mStatistics:[39m[22m
  [32mTotal files:[39m [36m31[39m
  [32mTotal lines:[39m [36m8774[39m
  [32mTotal size:[39m [36m273214 bytes[39m
  [32mEstimated tokens:[39m [36m68294[39m
