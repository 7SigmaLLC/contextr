// Plugin system integration with FileContextBuilder
// This file extends the core FileContextBuilder to support plugins

import { FileContextBuilder } from '../FileContextBuilder';
import { CollectedFile, FileCollectorConfig, FileContext } from '../types';
import { pluginManager, PluginType } from './PluginManager';

/**
 * Extended configuration for FileContextBuilder with plugin support
 */
export interface PluginEnabledConfig extends FileCollectorConfig {
  /** Enable or disable plugin system */
  enablePlugins?: boolean;

  /** Security scanner plugin IDs to use (all available if not specified) */
  securityScanners?: string[];

  /** Output renderer plugin ID to use */
  outputRenderer?: string;

  /** LLM reviewer plugin IDs to use (all available if not specified) */
  llmReviewers?: string[];

  /** Configuration for security scanners */
  securityScannerConfig?: any;

  /** Configuration for output renderers */
  outputRendererConfig?: any;

  /** Configuration for LLM reviewers */
  llmReviewerConfig?: any;

  /** Generate security reports */
  generateSecurityReports?: boolean;

  /** Generate summaries using LLM reviewers */
  generateSummaries?: boolean;
}

/**
 * Extended build result with plugin-generated data
 */
export interface PluginEnabledBuildResult {
  /** Original files */
  files: CollectedFile[];

  /** Rendered output */
  output: string;

  /** Security reports (if generated) */
  securityReports?: any[];

  /** Summaries generated by LLM reviewers (if generated) */
  summaries?: Record<string, string>;

  /** Total number of files */
  totalFiles: number;

  /** Total size of all files */
  totalSize: number;
}

/**
 * Extension of FileContextBuilder with plugin support
 */
export class PluginEnabledFileContextBuilder extends FileContextBuilder {
  private pluginConfig: PluginEnabledConfig;

  /**
   * Create a new plugin-enabled file context builder
   * @param config Configuration
   */
  constructor(config: PluginEnabledConfig = {}) {
    super(config);
    this.pluginConfig = config;
  }

  /**
   * Build context with plugin support
   * @param format Output format
   * @returns Build result with plugin-generated data
   */
  async build(format?: string): Promise<FileContext> {
    format = format || 'console';
    // Get base result from parent class
    const baseResult = await super.build(format);

    // If plugins are disabled, return base result
    if (this.pluginConfig.enablePlugins === false) {
      // Add security reports and summaries to the base result
      const result = baseResult as any;
      result.securityReports = [];
      result.summaries = {};
      if (!result.output) result.output = '';
      return result;
    }

    let files = baseResult.files;
    let output = baseResult.output;
    const securityReports: any[] = [];
    const summaries: Record<string, string> = {};

    try {
      // Load plugins if not already loaded
      await this.ensurePluginsLoaded();

      // Run security scanners
      if (pluginManager.getSecurityScanners().length > 0) {
        files = await pluginManager.runSecurityScanners(
          files,
          this.pluginConfig.securityScanners,
          this.pluginConfig.securityScannerConfig
        );

        // Generate security reports if requested
        if (this.pluginConfig.generateSecurityReports) {
          const reports = await pluginManager.generateSecurityReports(
            files,
            this.pluginConfig.securityScanners,
            this.pluginConfig.securityScannerConfig
          );
          securityReports.push(...reports);
        }
      }

      // Run LLM reviewers
      if (pluginManager.getLLMReviewers().length > 0) {
        files = await pluginManager.reviewFiles(
          files,
          this.pluginConfig.llmReviewers,
          this.pluginConfig.llmReviewerConfig
        );

        // Generate summaries if requested
        if (this.pluginConfig.generateSummaries) {
          const generatedSummaries = await pluginManager.generateSummaries(
            files,
            this.pluginConfig.llmReviewers,
            this.pluginConfig.llmReviewerConfig
          );
          Object.assign(summaries, generatedSummaries);
        }
      }

      // Use custom output renderer if specified
      if (this.pluginConfig.outputRenderer) {
        try {
          output = await pluginManager.renderOutput(
            files,
            this.pluginConfig.outputRenderer,
            this.pluginConfig.outputRendererConfig
          );
        } catch (error) {
          console.error(`Error using output renderer ${this.pluginConfig.outputRenderer}:`, error);
          // Fall back to original output
        }
      }
    } catch (error) {
      console.error('Error using plugins:', error);
      // Continue with base result on error
    }

    // Create the result object
    const result = {
      files,
      config: this.config,
      output,
      totalFiles: files.length,
      totalSize: files.reduce((sum, file) => sum + (file.meta?.size || 0), 0)
    } as any;

    // Add plugin-specific properties
    result.securityReports = securityReports;
    result.summaries = summaries;

    return result;
  }

  /**
   * Ensure plugins are loaded
   */
  private async ensurePluginsLoaded(): Promise<void> {
    // Check if any plugins are loaded
    if (pluginManager.getAllPlugins().length === 0) {
      await pluginManager.loadPlugins();
    }
  }

  /**
   * Get available plugin information
   */
  async getAvailablePlugins() {
    await this.ensurePluginsLoaded();

    return {
      securityScanners: pluginManager.getSecurityScanners().map(p => ({
        id: p.id,
        name: p.name,
        version: p.version,
        description: p.description
      })),
      outputRenderers: pluginManager.getOutputRenderers().map(p => ({
        id: p.id,
        name: p.name,
        version: p.version,
        description: p.description,
        formatName: p.getFormatName()
      })),
      llmReviewers: pluginManager.getLLMReviewers().map(p => ({
        id: p.id,
        name: p.name,
        version: p.version,
        description: p.description
      }))
    };
  }

  /**
   * Get configuration
   */
  getConfig(): PluginEnabledConfig {
    return this.pluginConfig;
  }

  /**
   * Set configuration
   * @param config New configuration
   */
  setConfig(config: PluginEnabledConfig): void {
    super.setConfig(config);
    this.pluginConfig = config;
  }
}
